var topic = "<!-- saved from url=(0024)http://docs.autodesk.com -->\n\
<html>\n\
   <head><script src=\"../scripts/yepnope.1.5.4-min.js\" type=\"text/javascript\"></script><script src=\"../scripts/lib/jquery-1.11.1.min.js\" type=\"text/javascript\"></script><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><meta name=\"product\" content=\"MOBPRO\"><meta name=\"release\" content=\"2018\"><meta name=\"book\" content=\"GeneralUser\"><meta name=\"created\" content=\"2017-09-08\"><meta name=\"topicid\" content=\"GUID-02FA7DD3-6C7A-4C6A-B7BC-824765AE1CB2\"><meta name=\"topic-type\" content=\"concept\">\n\
      <title>PtexExtractor/PtexLayout.cpp</title>\n\
   \n\
\n\
</head>\n\
   <body height=\"100%\"><div class=\"body_content\" id=\"body-content\"><link rel=\"stylesheet\" type=\"text/css\" href=\"cpp_ref/navtree.css\"><link rel=\"stylesheet\" type=\"text/css\" href=\"cpp_ref/doxygen.css\"><link rel=\"stylesheet\" type=\"text/css\" href=\"cpp_ref/tabs.css\"><link rel=\"stylesheet\" type=\"text/css\" href=\"style/adsk.cpm.css\"><script language=\"javascript\">var index = \'index.html\';</script><script>$(document).ready(function() { yepnope.injectJs(\"./scripts/ac_common.js\"); });</script><script type=\"text/javascript\">\n\
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == \'undefined\';\n\
var weAreIn21 = $(\'div#main.view-active\').length;\n\
var tocPrefix = \'\';\n\
if (weAreIn21)\n\
{ tocPrefix = \'cpp_ref/\'; }\n\
function cpp_ref_initializeToc(forceTrigger) {\n\
    cpp_ref_adsk_ref_toc.initResizable();\n\
    cpp_ref_adsk_ref_toc.initNavTree(\'_ptex_extractor_2_ptex_layout_8cpp-example.html\', tocPrefix);\n\
    dQuery(document).trigger(\'toc_initialized\');\n\
}\n\
if (tocSystemNeedsToBeLoaded)\n\
{\n\
	yepnope([{\n\
	load:[tocPrefix + \'json3.min.js\', tocPrefix + \'jquery.js\', tocPrefix + \'ref-toc-controller.js\', tocPrefix + \'dynsections.js\'],\n\
	complete: function() {\n\
	  if (typeof(dQuery) == \'undefined\')\n\
	  {\n\
	    dQuery = jQuery.noConflict(true);\n\
	  }\n\
	  else { jQuery.noConflict(true); }\n\
	  $(document).ready(cpp_ref_initializeToc);\n\
	}\n\
 	}])\n\
}\n\
if (!weAreIn21) { // if in AKN...\n\
$(window).load( function() {\n\
    setTimeout( function() {\n\
        var content = $(\'body > div\').not(\'#body-content\');     // take any divs under body that are not id=body-content\n\
        content.each( function() { \n\
            $(this).css( { \'padding-left\': $(this).css(\'margin-left\') } );       // and if they have any padding-left already, move it to margin-left.\n\
        } );\n\
        var width = cpp_ref_adsk_ref_toc.readFromStorage(\'width\');\n\
        content.css({marginLeft:parseInt(width)+6+\"px\"});\n\
    }, 100);\n\
} ); \n\
}\n\
</script><script>$(\"div#WidgetFloaterPanels,link[href*=\'microsofttranslator.com\'],script[src*=\'microsofttranslator.com\'],script[src*=\'bing.com\']\").remove();</script><script type=\'text/javascript\'>$(\"div#navigation,div#breadcrumbs,div#banner\").attr(\"translate\",\"no\"); var mtLocation = ((location && location.href && location.href.indexOf(\'https\') == 0)?\'https://ssl.microsofttranslator.com\':\'http://www.microsofttranslator.com\')+\'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages=\'; yepnope.injectJs(mtLocation, function() {}, { charset:\'utf-8\', type:\'text/javascript\' } );</script><script>\n\
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }\n\
 </script><!-- begin MT -->\n\
            \n\
            <div id=\'MicrosoftTranslatorWidget\' class=\'Dark\' style=\'float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden\'></div>\n\
      <div>\n\
         <div class=\"head\">\n\
            <h1>PtexExtractor/PtexLayout.cpp</h1>\n\
         </div>\n\
\n\
    <div id=\"top\"><!-- Generated by Doxygen 1.8.10 -->\n\
  <div id=\"navrow1\" class=\"tabs\">\n\
    <ul class=\"tablist\">\n\
      <li><a href=\"#!/url=./cpp_ref/index.html\"><span>Main&#160;Page</span></a></li>\n\
      <li><a href=\"#!/url=./cpp_ref/pages.html\"><span>Topics</span></a></li>\n\
      <li><a href=\"#!/url=./cpp_ref/modules.html\"><span>Modules</span></a></li>\n\
      <li><a href=\"#!/url=./cpp_ref/namespaces.html\"><span>Namespaces</span></a></li>\n\
      <li><a href=\"#!/url=./cpp_ref/annotated.html\"><span>Classes</span></a></li>\n\
      <li><a href=\"#!/url=./cpp_ref/files.html\"><span>Files</span></a></li>\n\
      <li><a href=\"#!/url=./cpp_ref/examples.html\"><span>Examples</span></a></li>\n\
    </ul>\n\
  </div>\n\
</div><!-- top -->\n\
<div id=\"side-nav\" class=\"ui-resizable side-nav-resizable\">\n\
  <div id=\"nav-tree\">\n\
    <div id=\"nav-tree-contents\">\n\
      <div id=\"nav-sync\" class=\"sync\"></div>\n\
    </div>\n\
  </div>\n\
  <div id=\"splitbar\" style=\"-moz-user-select:none;\" class=\"ui-resizable-handle\">\n\
  </div>\n\
</div>\n\
\n\
<div id=\"doc-content\">\n\
<div class=\"header\">\n\
  <div class=\"headertitle\">\n\
<div class=\"title\">PtexExtractor/PtexLayout.cpp</div>  </div>\n\
</div><!--header-->\n\
<div class=\"contents\">\n\
<div class=\"fragment\"><div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">//**************************************************************************/</span></div>\n\
<div class=\"line\"><span class=\"comment\">// Copyright (c) 2010 Autodesk, Inc.</span></div>\n\
<div class=\"line\"><span class=\"comment\">// All rights reserved.</span></div>\n\
<div class=\"line\"><span class=\"comment\">//</span></div>\n\
<div class=\"line\"><span class=\"comment\">// Use of this software is subject to the terms of the Autodesk license</span></div>\n\
<div class=\"line\"><span class=\"comment\">// agreement provided at the time of installation or download, or which</span></div>\n\
<div class=\"line\"><span class=\"comment\">// otherwise accompanies this software in either electronic or hard copy form.</span></div>\n\
<div class=\"line\"><span class=\"comment\">//</span></div>\n\
<div class=\"line\"><span class=\"comment\">//**************************************************************************/</span></div>\n\
<div class=\"line\"><span class=\"comment\">// DESCRIPTION:</span></div>\n\
<div class=\"line\"><span class=\"comment\">// CREATED: August 2010</span></div>\n\
<div class=\"line\"><span class=\"comment\">//**************************************************************************/</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;<a class=\"code\" href=\"#!/url=./cpp_ref/math_8h.html\">math.h</a>&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &quot;PtexLayout.h&quot;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;QtGui/QWidget&gt;</span></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#include &lt;QtGui/QGridLayout&gt;</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"preprocessor\">#define RES_TOL (0.1f)</span></div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// RTTI macro, needed for each class.</span></div>\n\
<div class=\"line\"><a name=\"a0\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/node_8h.html#ad54524b181b971ce9b577312ba2c5e65\">IMPLEMENT_SCLASS</a>( PtexLayout, Layout, <span class=\"stringliteral\">&quot;ptexlayout&quot;</span>, 5 );</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// Default constructor</span></div>\n\
<div class=\"line\">PtexLayout::PtexLayout( <span class=\"keywordtype\">void</span> ) :</div>\n\
<div class=\"line\">    m_eDistribution( this, <span class=\"stringliteral\">&quot;distribution&quot;</span> ),</div>\n\
<div class=\"line\">    m_fDensity( this, <span class=\"stringliteral\">&quot;density&quot;</span> ),</div>\n\
<div class=\"line\">    m_sTexelCount( this, <span class=\"stringliteral\">&quot;texelcount&quot;</span> )</div>\n\
<div class=\"line\">{ </div>\n\
<div class=\"line\">    m_eDistribution.SetName( QObject::tr(<span class=\"stringliteral\">&quot;Texel Distribution:&quot;</span>) );</div>\n\
<div class=\"line\">    m_eDistribution.SetToolTip( QObject::tr(<span class=\"stringliteral\">&quot;Controls how the sample points are distributed across the surface&quot;</span>) );</div>\n\
<div class=\"line\">    m_eDistribution.AddItem( QObject::tr(<span class=\"stringliteral\">&quot;Uniform&quot;</span>) );</div>\n\
<div class=\"line\">    m_eDistribution.AddItem( QObject::tr(<span class=\"stringliteral\">&quot;Based on Face Size&quot;</span>) );</div>\n\
<div class=\"line\">    m_eDistribution.AddItem( QObject::tr(<span class=\"stringliteral\">&quot;Based on UV Size&quot;</span>) );</div>\n\
<div class=\"line\">    m_eDistribution.AddItem( QObject::tr(<span class=\"stringliteral\">&quot;Use PTEX Setup&quot;</span>) );</div>\n\
<div class=\"line\">    m_eDistribution = 0;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    m_fDensity.SetName( QObject::tr(<span class=\"stringliteral\">&quot;Density:&quot;</span>) );</div>\n\
<div class=\"line\">    m_fDensity = 0.5f;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    m_sTexelCount.SetName( QObject::tr(<span class=\"stringliteral\">&quot;Number of texels:&quot;</span>) );</div>\n\
<div class=\"line\">    m_sTexelCount = <span class=\"stringliteral\">&quot;100000&quot;</span>;</div>\n\
<div class=\"line\">    m_iDesiredTexelCount = 100000;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// Create the user interface widget for the layout, which consists of a single widget at this moment, the quality slider.</span></div>\n\
<div class=\"line\"><a name=\"_a1\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_q_widget.html\">QWidget</a> *PtexLayout::UserInterface( <span class=\"keywordtype\">void</span> )</div>\n\
<div class=\"line\">{ </div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/class_q_widget.html\">QWidget</a> *<a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a775b535bae9cb9131338b1cda0807472\">w</a> = <span class=\"keyword\">new</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_q_widget.html\">QWidget</a>;</div>\n\
<div class=\"line\">    <a name=\"_a2\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_q_grid_layout.html\">QGridLayout</a> *l = <span class=\"keyword\">new</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_q_grid_layout.html\">QGridLayout</a>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <a name=\"_a3\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_q_label.html\">QLabel</a> *<a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a653819996e713edf9c01a5b564199189\">t</a> = <span class=\"keyword\">new</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_q_label.html\">QLabel</a>( QObject::tr(<span class=\"stringliteral\">&quot;Ptex resolution options&quot;</span>) );</div>\n\
<div class=\"line\">    <a name=\"_a4\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_q_font.html\">QFont</a> <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a691492ec0bd6383f91200e49f6ae40ed\">f</a> = t-&gt;<a name=\"a5\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_q_widget.html#aa20813efab33bbf989a516b8cdf7a0b6\">font</a>();</div>\n\
<div class=\"line\">    f.<a name=\"a6\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_q_font.html#ad25d9e2a3f37e54ee6052ceb3c387250\">setBold</a>( <span class=\"keyword\">true</span> );</div>\n\
<div class=\"line\">    t-&gt;<a name=\"a7\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_q_widget.html#af142d0a68748f3385baa77e9e3493448\">setFont</a>( f );</div>\n\
<div class=\"line\">    l-&gt;<a name=\"a8\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_q_grid_layout.html#aa93d3596c4e64dae54fd2c5a29a34982\">addWidget</a>( t );</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// If there are multiple attributes, they can be added to the QGridLayout object the same way. All added attribute will appear on the UI in a </span></div>\n\
<div class=\"line\">    <span class=\"comment\">// different row.</span></div>\n\
<div class=\"line\">    l-&gt;<a class=\"code\" href=\"#!/url=./cpp_ref/class_q_grid_layout.html#aa93d3596c4e64dae54fd2c5a29a34982\">addWidget</a>( m_fDensity.CreateEditorWidget( NULL, 150 ) );</div>\n\
<div class=\"line\">    l-&gt;<a class=\"code\" href=\"#!/url=./cpp_ref/class_q_grid_layout.html#aa93d3596c4e64dae54fd2c5a29a34982\">addWidget</a>( m_sTexelCount.CreateEditorWidget( NULL, 150 ) );</div>\n\
<div class=\"line\">    l-&gt;<a class=\"code\" href=\"#!/url=./cpp_ref/class_q_grid_layout.html#aa93d3596c4e64dae54fd2c5a29a34982\">addWidget</a>( m_eDistribution.CreateEditorWidget( NULL, 150 ) );</div>\n\
<div class=\"line\">    w-&gt;<a name=\"a9\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_q_widget.html#a76c1daa0d8f044bafb56b5c669feecc9\">setLayout</a>( l );        </div>\n\
<div class=\"line\">    <span class=\"keywordflow\">return</span> <a name=\"a10\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a775b535bae9cb9131338b1cda0807472\">w</a>;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// Calculate the area of a triangle using Heron&#39;s formula</span></div>\n\
<div class=\"line\"><span class=\"keywordtype\">float</span> TriangleArea( <span class=\"keyword\">const</span> Vector &amp;vC0, <span class=\"keyword\">const</span> Vector &amp;vC1, <span class=\"keyword\">const</span> Vector &amp;vC2 )</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">float</span> <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#ac8729153468b5dcf13f971b21d84d4e5\">a</a> = (vC0-vC1).Length();</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">float</span> <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a08f98740667f706cd68d5e873088ffa6\">b</a> = (vC0-vC2).Length();</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">float</span> <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a1f2d7f8147412c43ba2303a56f97ee73\">c</a> = (vC2-vC1).Length();</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">float</span> <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#ad585a1393cfa368fa9dc3d8ebff640d5\">s</a> = (a+b+<a name=\"a11\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a1f2d7f8147412c43ba2303a56f97ee73\">c</a>)*0.5f;</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">return</span> sqrtf(s*(s-a)*(s-b)*(s-c));</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// Main function, it processes the list of the given target surfaces, and collects the reference points on them.</span></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> PtexLayout::ProcessSurface( SubdivisionLevel *pSurface )</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">bool</span> bFiltering = m_eDistribution != distCustom;</div>\n\
<div class=\"line\">    InitializeResolution( pSurface );</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Indicate that a section of reference points has begun. Each mesh will have its own section.</span></div>\n\
<div class=\"line\">    BeginSection();</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ( pSurface-&gt;Type() == Mesh::typeQuadric )</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// Loop through all the faces of the mesh.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span> ( <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> f = 0; f &lt; pSurface-&gt;FaceCount(); f++ )</div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keywordtype\">int</span> iHRes = 3, iVRes = 3;</div>\n\
<div class=\"line\">            CalculateQuadResolution( f, iHRes, iVRes );</div>\n\
<div class=\"line\">            <span class=\"keywordtype\">int</span> iHSize = 1&lt;&lt;iHRes, iVSize = 1&lt;&lt;iVRes;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Loop through the points of the grid.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">for</span> ( <span class=\"keywordtype\">int</span> u = 0; u &lt; iHSize; u++ )</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">for</span> ( <span class=\"keywordtype\">int</span> <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a14cfbe2fc2234f5504618905b69d1e06\">v</a> = 0; <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a14cfbe2fc2234f5504618905b69d1e06\">v</a> &lt; iVSize; <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a14cfbe2fc2234f5504618905b69d1e06\">v</a>++ )</div>\n\
<div class=\"line\">                {</div>\n\
<div class=\"line\">                    <span class=\"comment\">// For each point on the grid we create a reference point, and call the ProcessSurfacePoint function.</span></div>\n\
<div class=\"line\">                    TargetLocation l;</div>\n\
<div class=\"line\">                    l.m_aLayoutData[dataURes] = u+(iHRes&lt;&lt;24);</div>\n\
<div class=\"line\">                    l.m_aLayoutData[dataVRes] = <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a14cfbe2fc2234f5504618905b69d1e06\">v</a>+(iVRes&lt;&lt;24);</div>\n\
<div class=\"line\">                    l.m_aLayoutData[dataFaceID] = <a name=\"a12\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a691492ec0bd6383f91200e49f6ae40ed\">f</a>;</div>\n\
<div class=\"line\">                        </div>\n\
<div class=\"line\">                    <span class=\"comment\">// To properly define the point on the surface, we use the index of the face, and the coordinates inside the face calculated from the grid coordinate.</span></div>\n\
<div class=\"line\">                    l.Fill( pSurface, f, (u+0.5f)/(<span class=\"keywordtype\">float</span>)iHSize, (<a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a14cfbe2fc2234f5504618905b69d1e06\">v</a>+0.5f)/(<span class=\"keywordtype\">float</span>)iVSize );</div>\n\
<div class=\"line\">                        </div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">if</span> ( !bFiltering )</div>\n\
<div class=\"line\">                        l.m_fDiameter = 0.0f;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                    ProcessSurfacePoint( l );</div>\n\
<div class=\"line\">                };</div>\n\
<div class=\"line\">        };</div>\n\
<div class=\"line\">        <span class=\"comment\">// Declaring the end of the section, which will tell the PtexUtilizer objects that no more reference points will be generated for the current mesh, so they can finish</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// writing the ptex file into the disk.</span></div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        PrepareAdjacency( pSurface );</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> iFaceID = 0;</div>\n\
<div class=\"line\">        <span class=\"comment\">// NSided case, this is more complicated than the quad one.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span> ( <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> f = 0; f &lt; pSurface-&gt;FaceCount(); f++ )</div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"comment\">// We go through all the polygons of the target mesh, so we skip fake triangles.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> ( pSurface-&gt;IsFakeTriangle( f ) )</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">continue</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Calculate the number of sides for this poly.</span></div>\n\
<div class=\"line\">            <span class=\"keywordtype\">int</span> iSideCount = 3, i = <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a691492ec0bd6383f91200e49f6ae40ed\">f</a>;</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">while</span> ( <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a691492ec0bd6383f91200e49f6ae40ed\">f &lt; pSurface-&gt;</a>FaceCount() &amp;&amp; pSurface-&gt;IsFakeTriangle( ++i ) )</div>\n\
<div class=\"line\">                iSideCount++;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// The number of the ptex faces generated for this polygon depends on the number of sides. For quads, we have </span></div>\n\
<div class=\"line\">            <span class=\"comment\">// to generate a single ptex face, for other polygons we generate one ptex face for each vertex, so the number</span></div>\n\
<div class=\"line\">            <span class=\"comment\">// of ptex faces in that case is the same as the number of sides in the polygon.</span></div>\n\
<div class=\"line\">            <span class=\"keywordtype\">int</span> iSubFaceCount = iSideCount;</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> ( iSideCount == 4 )</div>\n\
<div class=\"line\">                iSubFaceCount = 1;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Collect the object space position of the corners of the polygon.</span></div>\n\
<div class=\"line\">            Vector aCorners[16];</div>\n\
<div class=\"line\">            Vector aUVCorners[16];</div>\n\
<div class=\"line\">            <a name=\"a13\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/mudbox_8h.html#a4574db3fa92e5236e049b3e67bc51cd9\">MB_ONBUG</a>( iSideCount &gt;= 16 )</div>\n\
<div class=\"line\">                continue;</div>\n\
<div class=\"line\">            aCorners[0] = pSurface-&gt;TriangleVertexPosition( f, 0 );</div>\n\
<div class=\"line\">            aCorners[1] = pSurface-&gt;TriangleVertexPosition( f, 1 );</div>\n\
<div class=\"line\">            for ( <span class=\"keywordtype\">int</span> i = 0; i &lt; iSideCount-2; i++ )</div>\n\
<div class=\"line\">                aCorners[i+2] = pSurface-&gt;TriangleVertexPosition( f+i, 2 );</div>\n\
<div class=\"line\">            if ( pSurface-&gt;HasTC() )</div>\n\
<div class=\"line\">            {</div>\n\
<div class=\"line\">                aUVCorners[0] = pSurface-&gt;TriangleVertexTC( f, 0 );</div>\n\
<div class=\"line\">                aUVCorners[1] = pSurface-&gt;TriangleVertexTC( f, 1 );</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">for</span> ( <span class=\"keywordtype\">int</span> i = 0; i &lt; iSideCount-2; i++ )</div>\n\
<div class=\"line\">                    aUVCorners[i+2] = pSurface-&gt;TriangleVertexTC( f+i, 2 );</div>\n\
<div class=\"line\">            };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Calculate the position of the center of the polygon/</span></div>\n\
<div class=\"line\">            Vector vCenter;</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">for</span> ( <span class=\"keywordtype\">int</span> j = 0; j &lt; iSideCount; j++ )</div>\n\
<div class=\"line\">                vCenter += aCorners[j];</div>\n\
<div class=\"line\">            vCenter *= 1/(float)iSideCount;</div>\n\
<div class=\"line\">            Vector vUVCenter;</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">for</span> ( <span class=\"keywordtype\">int</span> j = 0; j &lt; iSideCount; j++ )</div>\n\
<div class=\"line\">                vUVCenter += aUVCorners[j];</div>\n\
<div class=\"line\">            vUVCenter *= 1/(float)iSideCount;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// Go through the subfaces.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">for</span> ( <span class=\"keywordtype\">int</span> iSubFace = 0; iSubFace &lt; iSubFaceCount; iSubFace++ )</div>\n\
<div class=\"line\">            {</div>\n\
<div class=\"line\">                Vector vCorner0, vCorner1, vCorner2, vCorner3;</div>\n\
<div class=\"line\">                Vector vUVCorner0, vUVCorner1, vUVCorner2, vUVCorner3;</div>\n\
<div class=\"line\">                <span class=\"keywordtype\">int</span> iURes = 3, iVRes = 3;</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> ( iSideCount == 4 )</div>\n\
<div class=\"line\">                {</div>\n\
<div class=\"line\">                    <span class=\"comment\">// When this polygon is a quad, then there is a single ptex face, which covers the full area of the quad.</span></div>\n\
<div class=\"line\">                    <a name=\"a14\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/mudbox_8h.html#a24f4fe4a32c8501c3cae26db72954a30\">MB_ASSERT</a>( iSubFace == 0 );</div>\n\
<div class=\"line\">                    vCorner0 = aCorners[0];</div>\n\
<div class=\"line\">                    vCorner1 = aCorners[1];</div>\n\
<div class=\"line\">                    vCorner2 = aCorners[2];</div>\n\
<div class=\"line\">                    vCorner3 = aCorners[3];</div>\n\
<div class=\"line\">                    vUVCorner0 = aUVCorners[0];</div>\n\
<div class=\"line\">                    vUVCorner1 = aUVCorners[1];</div>\n\
<div class=\"line\">                    vUVCorner2 = aUVCorners[2];</div>\n\
<div class=\"line\">                    vUVCorner3 = aUVCorners[3];</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">                {</div>\n\
<div class=\"line\">                    <span class=\"comment\">// When the polygon is not a quad, then each vertex will have its own ptex face. This ptex face will</span></div>\n\
<div class=\"line\">                    <span class=\"comment\">// cover a rectangular area surrounded by the vertex, the center of the two edges attached to the</span></div>\n\
<div class=\"line\">                    <span class=\"comment\">// vertex, and the center of the polygon.</span></div>\n\
<div class=\"line\">                    iURes--;        <span class=\"comment\">// Since this is a subface, we halve the resolution.</span></div>\n\
<div class=\"line\">                    iVRes--;</div>\n\
<div class=\"line\">                    vCorner0 = aCorners[iSubFace];</div>\n\
<div class=\"line\">                    vCorner1 = (vCorner0+aCorners[(iSubFace+1)%iSideCount])*0.5f;</div>\n\
<div class=\"line\">                    vCorner2 = vCenter;</div>\n\
<div class=\"line\">                    vCorner3 = (vCorner0+aCorners[(iSubFace-1+iSideCount)%iSideCount])*0.5f;</div>\n\
<div class=\"line\">                    vUVCorner0 = aUVCorners[iSubFace];</div>\n\
<div class=\"line\">                    vUVCorner1 = (vUVCorner0+aUVCorners[(iSubFace+1)%iSideCount])*0.5f;</div>\n\
<div class=\"line\">                    vUVCorner2 = vUVCenter;</div>\n\
<div class=\"line\">                    vUVCorner3 = (vUVCorner0+aUVCorners[(iSubFace-1+iSideCount)%iSideCount])*0.5f;</div>\n\
<div class=\"line\">                };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> ( m_eDistribution != distUVArea )</div>\n\
<div class=\"line\">                    CalculateFaceResolution( vCorner0, vCorner1, vCorner2, vCorner3, f, iURes, iVRes );</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">                    CalculateFaceResolution( vUVCorner0, vUVCorner1, vUVCorner2, vUVCorner3, f, iURes, iVRes );</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">                <span class=\"comment\">// Now that we have the object space position of the corners of the ptex face, we generate reference</span></div>\n\
<div class=\"line\">                <span class=\"comment\">// points in that area in a grid layout.</span></div>\n\
<div class=\"line\">                <span class=\"keywordtype\">int</span> iUSize = 1 &lt;&lt; iURes, iVSize = 1 &lt;&lt; iVRes;</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">for</span> ( <span class=\"keywordtype\">int</span> iU = 0; iU &lt; iUSize; iU++ )</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">for</span> ( <span class=\"keywordtype\">int</span> iV = 0; iV &lt; iVSize; iV++ )</div>\n\
<div class=\"line\">                    {</div>\n\
<div class=\"line\">                        TargetLocation l;</div>\n\
<div class=\"line\">                        l.m_aLayoutData[dataURes] = iU+(iURes&lt;&lt;24);</div>\n\
<div class=\"line\">                        l.m_aLayoutData[dataVRes] = iV+(iVRes&lt;&lt;24);</div>\n\
<div class=\"line\">                        l.m_aLayoutData[dataFaceID] = iFaceID;</div>\n\
<div class=\"line\">                        <span class=\"keywordflow\">if</span> ( iSubFaceCount &gt; 1 )</div>\n\
<div class=\"line\">                            l.m_aLayoutData[dataFaceID] |= 0x80000000;</div>\n\
<div class=\"line\">                            </div>\n\
<div class=\"line\">                        <span class=\"keywordtype\">float</span> fU = ((float)iU+0.5f)/iUSize, fV = ((float)iV+0.5f)/iVSize;</div>\n\
<div class=\"line\">                        Vector vH0 = vCorner0+(vCorner1-vCorner0)*fU;</div>\n\
<div class=\"line\">                        Vector vH1 = vCorner3+(vCorner2-vCorner3)*fU;</div>\n\
<div class=\"line\">                        l.FillNSided( pSurface, f, vH0+(vH1-vH0)*fV );  <span class=\"comment\">// We initialize the location based on the object space position of the reference point.</span></div>\n\
<div class=\"line\">                        <span class=\"keywordflow\">if</span> ( iSubFaceCount == 1 &amp;&amp; !bFiltering )</div>\n\
<div class=\"line\">                            l.m_fDiameter = 0.0f;</div>\n\
<div class=\"line\">                        ProcessSurfacePoint( l );</div>\n\
<div class=\"line\">                    };</div>\n\
<div class=\"line\">                iFaceID++;</div>\n\
<div class=\"line\">            };</div>\n\
<div class=\"line\">        };</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\">    EndSection();</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ( m_eDistribution != distCustom )</div>\n\
<div class=\"line\">        <a name=\"a15\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/namespacemudbox.html#ae9df9ee935ec6744f98a1585d9db01df\">Kernel</a>()-&gt;Log( <a name=\"_a16\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_q_string.html\">QString</a>( <span class=\"stringliteral\">&quot;Mesh %1 processed with %2 samples (desired: %3).\\n&quot;</span> ).arg( pSurface-&gt;Name() ).arg( m_sRes.m_iTexelCount ).<a name=\"a17\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_q_string.html#a5feeac90490ef91a9faf3021dab55c80\">arg</a>( m_iDesiredTexelCount ) );</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/namespacemudbox.html#ae9df9ee935ec6744f98a1585d9db01df\">Kernel</a>()-&gt;Log( <a class=\"code\" href=\"#!/url=./cpp_ref/class_q_string.html\">QString</a>( <span class=\"stringliteral\">&quot;Mesh %1 processed with %2 samples.\\n&quot;</span> ).arg( pSurface-&gt;Name() ).arg( m_sRes.m_iTexelCount ) );</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This function initializates data structures used for resolution calculation.</span></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> PtexLayout::InitializeResolution( <span class=\"keyword\">const</span> Mesh *pMesh )</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">        m_sRes.m_pMesh = pMesh;</div>\n\
<div class=\"line\">        m_sRes.m_pUVGen = pMesh-&gt;ChildByClass&lt;<a name=\"_a18\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/class_u_v_generator_node.html\">UVGeneratorNode</a>&gt;( false );</div>\n\
<div class=\"line\">        m_sRes.m_iTexelCount = 0;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// If custom distribution is selected, we don&#39;t need much initialization, since the resolution for each face is controlled </span></div>\n\
<div class=\"line\">        <span class=\"comment\">// explicitly by the user through the UVGeneratorNode object.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> ( m_eDistribution == distCustom )</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// For UV and World based distributions, the total area of the surface has to be calculated.</span></div>\n\
<div class=\"line\">        m_sRes.m_fTotalSurfaceArea = 0.0f;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> ( m_eDistribution == distWorldArea || m_eDistribution == distUVArea )</div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">for</span> ( <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> i = 0; i &lt; pMesh-&gt;FaceCount(); i++ )</div>\n\
<div class=\"line\">            {</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> ( pMesh-&gt;Type() == Mesh::typeTriangular )</div>\n\
<div class=\"line\">                {</div>\n\
<div class=\"line\">                    Vector <a name=\"a19\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a7062a23d1d434121d4a88f530703d06a\">v0</a>, <a name=\"a20\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a0779c3b73f9aa3a0ac5b0139b5d291d9\">v1</a>, <a name=\"a21\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a9a09a1837922b2b806f4589096a52049\">v2</a>;</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">if</span> ( m_eDistribution == distUVArea )</div>\n\
<div class=\"line\">                    {</div>\n\
<div class=\"line\">                        v0 = pMesh-&gt;TriangleVertexTC( i, 0 );</div>\n\
<div class=\"line\">                        v1 = pMesh-&gt;TriangleVertexTC( i, 1 );</div>\n\
<div class=\"line\">                        v2 = pMesh-&gt;TriangleVertexTC( i, 2 );</div>\n\
<div class=\"line\">                    }</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">                    {</div>\n\
<div class=\"line\">                        v0 = pMesh-&gt;TriangleVertexPosition( i, 0 );</div>\n\
<div class=\"line\">                        v1 = pMesh-&gt;TriangleVertexPosition( i, 1 );</div>\n\
<div class=\"line\">                        v2 = pMesh-&gt;TriangleVertexPosition( i, 2 );</div>\n\
<div class=\"line\">                    };</div>\n\
<div class=\"line\">                    m_sRes.m_fTotalSurfaceArea += TriangleArea( v0, v1, v2 );</div>\n\
<div class=\"line\">                }</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">                {</div>\n\
<div class=\"line\">                    Vector <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a7062a23d1d434121d4a88f530703d06a\">v0</a>, <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a0779c3b73f9aa3a0ac5b0139b5d291d9\">v1</a>, <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a9a09a1837922b2b806f4589096a52049\">v2</a>, <a name=\"a22\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#acc806b31cbf466ceba6555983d8b814d\">v3</a>;</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">if</span> ( m_eDistribution == distUVArea )</div>\n\
<div class=\"line\">                    {</div>\n\
<div class=\"line\">                        v0 = pMesh-&gt;QuadVertexTC( i, 0 );</div>\n\
<div class=\"line\">                        v1 = pMesh-&gt;QuadVertexTC( i, 1 );</div>\n\
<div class=\"line\">                        v2 = pMesh-&gt;QuadVertexTC( i, 2 );</div>\n\
<div class=\"line\">                        v3 = pMesh-&gt;QuadVertexTC( i, 3 );</div>\n\
<div class=\"line\">                    }</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">                    {</div>\n\
<div class=\"line\">                        v0 = pMesh-&gt;QuadVertexPosition( i, 0 );</div>\n\
<div class=\"line\">                        v1 = pMesh-&gt;QuadVertexPosition( i, 1 );</div>\n\
<div class=\"line\">                        v2 = pMesh-&gt;QuadVertexPosition( i, 2 );</div>\n\
<div class=\"line\">                        v3 = pMesh-&gt;QuadVertexPosition( i, 3 );</div>\n\
<div class=\"line\">                    };</div>\n\
<div class=\"line\">                    m_sRes.m_fTotalSurfaceArea += TriangleArea( v0, v1, v2 );</div>\n\
<div class=\"line\">                    m_sRes.m_fTotalSurfaceArea += TriangleArea( v0, v2, v3 );</div>\n\
<div class=\"line\">                };</div>\n\
<div class=\"line\">            };</div>\n\
<div class=\"line\">        }</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"comment\">// When uniform distribution is selected, each face will get the same resolution, so we can assume that the area of each face is one.</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> ( pMesh-&gt;Type() == Mesh::typeQuadric )</div>\n\
<div class=\"line\">                m_sRes.m_fTotalSurfaceArea = (<span class=\"keywordtype\">float</span>)pMesh-&gt;FaceCount();</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">            {</div>\n\
<div class=\"line\">                <span class=\"keywordtype\">int</span> s = 3;</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">for</span> ( <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> f = 0; f &lt; pMesh-&gt;FaceCount(); f++ )</div>\n\
<div class=\"line\">                {</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">if</span> ( <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a691492ec0bd6383f91200e49f6ae40ed\">f &lt; pMesh-&gt;</a>FaceCount()-1 &amp;&amp; pMesh-&gt;IsFakeTriangle( f+1 ) )</div>\n\
<div class=\"line\">                        s++;</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">                    {</div>\n\
<div class=\"line\">                        <span class=\"keywordflow\">if</span> ( s == 4 )</div>\n\
<div class=\"line\">                            m_sRes.m_fTotalSurfaceArea++;</div>\n\
<div class=\"line\">                        <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">                            m_sRes.m_fTotalSurfaceArea += <a name=\"a23\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#ad585a1393cfa368fa9dc3d8ebff640d5\">s</a>;</div>\n\
<div class=\"line\">                        s = 3;</div>\n\
<div class=\"line\">                    };</div>\n\
<div class=\"line\">                };</div>\n\
<div class=\"line\">            };</div>\n\
<div class=\"line\">        };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Ptex only allows power of two resolutions, so the ideal resolution should be aligned to the closes power of two values. </span></div>\n\
<div class=\"line\">        <span class=\"comment\">// When the ideal resolution is not close to a power of two number, then the plugin chooses based on which resolution fits </span></div>\n\
<div class=\"line\">        <span class=\"comment\">// better for the current desired texel count. m_fTolerance controls how close the face should be to a power of two number,</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// to disable this optimization. When uniform distribution is choosed, each face will have the same ideal resolution, so the</span></div>\n\
<div class=\"line\">        <span class=\"comment\">// optimizations described above should be enabled to each face.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> ( m_eDistribution == distUniform )</div>\n\
<div class=\"line\">            m_sRes.m_fTolerance = 0.5f;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">            m_sRes.m_fTolerance = RES_TOL;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        m_sRes.m_fProcessedArea = 0.0f;</div>\n\
<div class=\"line\">};  </div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This function calculates the resolution for a given quad.</span></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> PtexLayout::CalculateQuadResolution( <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> iQuadIndex, <span class=\"keywordtype\">int</span> &amp;iHRes, <span class=\"keywordtype\">int</span> &amp;iVRes )</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"keyword\">const</span> Mesh *pMesh = m_sRes.m_pMesh;</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ( m_eDistribution == distUVArea )</div>\n\
<div class=\"line\">        CalculateFaceResolution( pMesh-&gt;QuadVertexTC( iQuadIndex, 0 ), pMesh-&gt;QuadVertexTC( iQuadIndex, 1 ), pMesh-&gt;QuadVertexTC( iQuadIndex, 2 ), pMesh-&gt;QuadVertexTC( iQuadIndex, 3 ), iQuadIndex, iHRes, iVRes );</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">        CalculateFaceResolution( pMesh-&gt;QuadVertexPosition( iQuadIndex, 0 ), pMesh-&gt;QuadVertexPosition( iQuadIndex, 1 ), pMesh-&gt;QuadVertexPosition( iQuadIndex, 2 ), pMesh-&gt;QuadVertexPosition( iQuadIndex, 3 ), iQuadIndex, iHRes, iVRes );</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This function calculates which is the closest power of two number to an ideal resolution. If the ideal resolution is not close</span></div>\n\
<div class=\"line\"><span class=\"comment\">// to a power of two number, the function is trying to choose the one which fits the desired texel count better.</span></div>\n\
<div class=\"line\"><span class=\"keywordtype\">int</span> PtexLayout::Calculate1DResolution( <span class=\"keywordtype\">float</span> fIdeal )</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">float</span> f = logf(fIdeal)/logf(2.0f);</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">float</span> fRac = f-floorf(f);</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ( f &lt; 0 )</div>\n\
<div class=\"line\">        f = 0;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// fRac is the exponent of the distance from the lower power of two number. If this distance is close to 0 or 1 (i.e. fIdeal is close to a power of</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// two number), then that value will be choosed.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ( fRac &lt; 0.5f-m_sRes.m_fTolerance )</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> <a name=\"a24\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#aa813ad7a4a00cda401ffd0c336154620\">int</a>(f);</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ( fRac &gt; 0.5f+m_sRes.m_fTolerance )</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#aa813ad7a4a00cda401ffd0c336154620\">int</a>(f)+1;</div>\n\
<div class=\"line\">    </div>\n\
<div class=\"line\">    <span class=\"comment\">// In other cases, the decision will be made based on the current state of the extraction.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> iExpectedTexelCount = m_sRes.m_iTexelCount*(m_sRes.m_fTotalSurfaceArea/m_sRes.m_fProcessedArea);</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ( iExpectedTexelCount &lt; m_iDesiredTexelCount )</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#aa813ad7a4a00cda401ffd0c336154620\">int</a>(f)+1;</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#aa813ad7a4a00cda401ffd0c336154620\">int</a>(f);</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This function calculates the resolution for an arbitrary ptex face.</span></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> PtexLayout::CalculateFaceResolution( <span class=\"keyword\">const</span> Vector &amp;vC0, <span class=\"keyword\">const</span> Vector &amp;vC1, <span class=\"keyword\">const</span> Vector &amp;vC2, <span class=\"keyword\">const</span> Vector &amp;vC3, <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> iFaceIndex, <span class=\"keywordtype\">int</span> &amp;iHRes, <span class=\"keywordtype\">int</span> &amp;iVRes )</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// If custom distribution is selected, the resolution is directly controlled by the UVGeneratorNode.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ( m_eDistribution == distCustom )</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/mudbox_8h.html#a4574db3fa92e5236e049b3e67bc51cd9\">MB_ONBUG</a>( m_sRes.m_pUVGen == 0 )</div>\n\
<div class=\"line\">            return;</div>\n\
<div class=\"line\">        iHRes = m_sRes.m_pUVGen-&gt;FaceSizeExponent( iFaceIndex )[0];</div>\n\
<div class=\"line\">        iVRes = m_sRes.m_pUVGen-&gt;FaceSizeExponent( iFaceIndex )[1];</div>\n\
<div class=\"line\">        m_sRes.m_iTexelCount += (1&lt;&lt;iHRes)*(1&lt;&lt;iVRes);</div>\n\
<div class=\"line\">        return;</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// In other cases the area of the face is controlling the resolution. The bigger the size, the bigger the resolution will be.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">float</span> fFaceArea = TriangleArea( vC0, vC1, vC2 )+TriangleArea( vC1, vC2, vC3 );</div>\n\
<div class=\"line\">    <span class=\"comment\">// If uniform distribution is selected, the area of each face is assumed to be one. This way each face will get similar resolutions.</span></div>\n\
<div class=\"line\">    if ( m_eDistribution == distUniform )</div>\n\
<div class=\"line\">        fFaceArea = 1.0;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">float</span> fIdealTexelCount = m_iDesiredTexelCount*fFaceArea/m_sRes.m_fTotalSurfaceArea;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">float</span> fWidth = ((vC0-vC1).Length()+(vC2-vC3).Length())*0.5f;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">float</span> fHeight = ((vC0-vC3).Length()+(vC1-vC2).Length())*0.5f;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">float</span> fAspect = fWidth/fHeight;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">float</span> fIdealWidth = sqrtf(fIdealTexelCount*fAspect);</div>\n\
<div class=\"line\">    iHRes = Calculate1DResolution( fIdealWidth );</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">float</span> fIdealHeight = fIdealTexelCount/(1&lt;&lt;iHRes);</div>\n\
<div class=\"line\">    iVRes = Calculate1DResolution( fIdealHeight );</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/mudbox_8h.html#a4574db3fa92e5236e049b3e67bc51cd9\">MB_ONBUG</a>( iHRes &lt; 0 )</div>\n\
<div class=\"line\">        iHRes = 0;</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/mudbox_8h.html#a4574db3fa92e5236e049b3e67bc51cd9\">MB_ONBUG</a>( iVRes &lt; 0 )</div>\n\
<div class=\"line\">        iVRes = 0;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    m_sRes.m_fProcessedArea += fFaceArea;</div>\n\
<div class=\"line\">    m_sRes.m_iTexelCount += (1&lt;&lt;iHRes)*(1&lt;&lt;iVRes);</div>\n\
<div class=\"line\">    return;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This function prepares the object for the extraction, and returns the number of the expected reference points.</span></div>\n\
<div class=\"line\"><span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> PtexLayout::Prepare( <span class=\"keywordtype\">void</span> )</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// If custom distribution is selected, the number of the texels is controlled by the UVGeneratorNode attached to the mesh</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// for other distributions, the number of texels will be close to m_iDesiredTexelCount</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ( m_eDistribution == distCustom )</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> iRefCount = 0;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span> ( <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> c = 0; c &lt; Extractor()-&gt;TargetCount(); c++ )</div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> Mesh *<a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#aa5367c14d90f462230c2611b81b41d23\">p</a> = Extractor()-&gt;TargetMesh( c );</div>\n\
<div class=\"line\">            <span class=\"keyword\">const</span> <a class=\"code\" href=\"#!/url=./cpp_ref/class_u_v_generator_node.html\">UVGeneratorNode</a> *pUVGen = p-&gt;<a name=\"a25\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/classmudbox_1_1_tree_node.html#a4af55b252dcecf719f083e2ecc16d332\">ChildByClass</a>&lt;<a class=\"code\" href=\"#!/url=./cpp_ref/class_u_v_generator_node.html\">UVGeneratorNode</a>&gt;( false );</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> ( pUVGen == 0 )</div>\n\
<div class=\"line\">            {</div>\n\
<div class=\"line\">                m_eDistribution = distUniform;</div>\n\
<div class=\"line\">                <a name=\"a26\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/mudbox_8h.html#a78d8bd615152a82160d33c6063f0e308\">MB_ERROR</a>( QObject::tr(<span class=\"stringliteral\">&quot;\\&quot;Use PTEX Setup\\&quot; can only be selected if the target mesh is already set up for PTEX.&quot;</span>) );</div>\n\
<div class=\"line\">            };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">            <span class=\"comment\">// each face has to be checked, and their resolution should be summed</span></div>\n\
<div class=\"line\">            <span class=\"keywordflow\">for</span> ( <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> f = 0; f &lt; p-&gt;FaceCount(); f++ )</div>\n\
<div class=\"line\">            {</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> ( p-&gt;Type() == Mesh::typeTriangular &amp;&amp; p-&gt;IsFakeTriangle( f ) )</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">continue</span>;</div>\n\
<div class=\"line\">                UVGeneratorNode::DimData4 d = pUVGen-&gt;<a name=\"a27\"></a>FaceSize( f );</div>\n\
<div class=\"line\">                iRefCount += d.m_iData[0]*d.m_iData[1];</div>\n\
<div class=\"line\">            };</div>\n\
<div class=\"line\">        };</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> iRefCount;</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ( m_eDistribution == distUVArea )</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">for</span> ( <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> i = 0; i &lt; Extractor()-&gt;TargetCount(); i++ )</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> ( !Extractor()-&gt;TargetMesh( i )-&gt;HasTC() )</div>\n\
<div class=\"line\">            {</div>\n\
<div class=\"line\">                m_eDistribution = distUniform;</div>\n\
<div class=\"line\">                <a class=\"code\" href=\"#!/url=./cpp_ref/mudbox_8h.html#a78d8bd615152a82160d33c6063f0e308\">MB_ERROR</a>( QObject::tr(<span class=\"stringliteral\">&quot;\\&quot;Based on UV Size\\&quot; can only be selected if the target mesh has texture coordinates.&quot;</span>) );</div>\n\
<div class=\"line\">            };</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">return</span> m_iDesiredTexelCount;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// Serialize the state of the object. We only need to serialize the only one attribute which belongs to this class.</span></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> PtexLayout::Serialize( Stream &amp;s )</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ( s.IsNewerThan( 0, <span class=\"keyword\">this</span> ) )</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> ( s.IsNewerThan( 2, <span class=\"keyword\">this</span> ) )</div>\n\
<div class=\"line\">            s == m_fDensity == m_eDistribution;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> ( s.IsNewerThan( 3, <span class=\"keyword\">this</span> ) )</div>\n\
<div class=\"line\">            s == m_iDesiredTexelCount;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">if</span> ( s.IsNewerThan( 1, <span class=\"keyword\">this</span> ) )</div>\n\
<div class=\"line\">            {</div>\n\
<div class=\"line\">                <span class=\"keywordtype\">int</span> i;</div>\n\
<div class=\"line\">                s &gt;&gt; i;</div>\n\
<div class=\"line\">            }</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">            {</div>\n\
<div class=\"line\">                <span class=\"keywordtype\">float</span> <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a691492ec0bd6383f91200e49f6ae40ed\">f</a>;</div>\n\
<div class=\"line\">                s &gt;&gt; <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a691492ec0bd6383f91200e49f6ae40ed\">f</a>;</div>\n\
<div class=\"line\">            };</div>\n\
<div class=\"line\">        };</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ( s.IsNewerThan( 4, <span class=\"keyword\">this</span> ) )</div>\n\
<div class=\"line\">        s == m_sTexelCount;</div>\n\
<div class=\"line\">    Layout::Serialize( s );</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> PtexLayout::OnNodeEvent( <span class=\"keyword\">const</span> Attribute &amp;a, <a name=\"a28\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/namespacemudbox.html#a8d88d2a841f889dace76ffcd8d6b06da\">NodeEventType</a> e )</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ( a == m_fDensity &amp;&amp; e == <a name=\"a29\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/namespacemudbox.html#a8d88d2a841f889dace76ffcd8d6b06daa274758890f9a27906be7336f4b8e4780\">etValueChanged</a> )</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> ( m_fDensity &gt; 1 )</div>\n\
<div class=\"line\">            m_fDensity = 1;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> ( m_fDensity &lt; 0 )</div>\n\
<div class=\"line\">            m_fDensity = 0;</div>\n\
<div class=\"line\">        <span class=\"keywordtype\">int</span> iTargetSampleCount = 10000*powf(100, m_fDensity);</div>\n\
<div class=\"line\">        m_sTexelCount.SetValue( <a class=\"code\" href=\"#!/url=./cpp_ref/class_q_string.html\">QString</a>(<span class=\"stringliteral\">&quot;%1&quot;</span>).arg(iTargetSampleCount), <span class=\"keyword\">true</span> );</div>\n\
<div class=\"line\">        m_iDesiredTexelCount = iTargetSampleCount;</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ( a == m_eDistribution &amp;&amp; e == <a class=\"code\" href=\"#!/url=./cpp_ref/namespacemudbox.html#a8d88d2a841f889dace76ffcd8d6b06daa274758890f9a27906be7336f4b8e4780\">etValueChanged</a> )</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> ( m_eDistribution == distCustom )</div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            <span class=\"keywordflow\">for</span> ( <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> i = 0; i &lt; Extractor()-&gt;TargetCount(); i++ )</div>\n\
<div class=\"line\">            {</div>\n\
<div class=\"line\">                <a class=\"code\" href=\"#!/url=./cpp_ref/class_u_v_generator_node.html\">UVGeneratorNode</a> *pG = Extractor()-&gt;TargetMesh( i )-&gt;<a class=\"code\" href=\"#!/url=./cpp_ref/classmudbox_1_1_tree_node.html#a4af55b252dcecf719f083e2ecc16d332\">ChildByClass</a>&lt;<a class=\"code\" href=\"#!/url=./cpp_ref/class_u_v_generator_node.html\">UVGeneratorNode</a>&gt;( false );</div>\n\
<div class=\"line\">                <span class=\"keywordflow\">if</span> ( !pG )</div>\n\
<div class=\"line\">                {</div>\n\
<div class=\"line\">                    <a class=\"code\" href=\"#!/url=./cpp_ref/namespacemudbox.html#ae9df9ee935ec6744f98a1585d9db01df\">Kernel</a>()-&gt;Interface()-&gt;HUDMessageShow( QObject::tr(<span class=\"stringliteral\">&quot;Use PTEX Setup can only be selected if the target mesh is already set up for PTEX.&quot;</span>),  <a name=\"a30\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/classmudbox_1_1_interface.html#a26e31204f799b1a1db85565fc5a98b99a6d1628d017e93eb59b9a74b0cdc9d904\">mudbox::Interface::HUDmsgFade</a> );</div>\n\
<div class=\"line\">                    m_eDistribution.SetValue( distUniform, <span class=\"keyword\">true</span> );</div>\n\
<div class=\"line\">                    <span class=\"keywordflow\">return</span>;</div>\n\
<div class=\"line\">                };</div>\n\
<div class=\"line\">            };</div>\n\
<div class=\"line\">        };</div>\n\
<div class=\"line\">        m_fDensity.SetConst( m_eDistribution == distCustom );</div>\n\
<div class=\"line\">        m_sTexelCount.SetConst( m_eDistribution == distCustom );</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ( a == m_sTexelCount &amp;&amp; e == <a class=\"code\" href=\"#!/url=./cpp_ref/namespacemudbox.html#a8d88d2a841f889dace76ffcd8d6b06daa274758890f9a27906be7336f4b8e4780\">etValueChanged</a> )</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/qglobal_8h.html#ae06b4c193080e9aa8b6cd7f7c9f517ec\">qlonglong</a> iDesiredTexelCount = m_sTexelCount.Value().toLongLong();</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> ( iDesiredTexelCount &lt; 1 )</div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            iDesiredTexelCount = 1;</div>\n\
<div class=\"line\">            m_sTexelCount = <span class=\"stringliteral\">&quot;1&quot;</span>;</div>\n\
<div class=\"line\">        };</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> ( iDesiredTexelCount &gt; 100000000 )</div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            iDesiredTexelCount = 100000000;</div>\n\
<div class=\"line\">            m_sTexelCount = <span class=\"stringliteral\">&quot;100000000&quot;</span>;</div>\n\
<div class=\"line\">        };</div>\n\
<div class=\"line\">        m_iDesiredTexelCount = iDesiredTexelCount;</div>\n\
<div class=\"line\">        <span class=\"keywordtype\">float</span> fDensity = logf(m_iDesiredTexelCount/10000)/logf(100.0f);</div>\n\
<div class=\"line\">        fDensity = <a name=\"a31\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/namespacemudbox.html#a33536fce33010513e0a87ec163ed29ff\">Min</a>(<a name=\"a32\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/namespacemudbox.html#a990360af7f7250cdaec94844b139fa74\">Max</a>(fDensity,0.0f),1.0f);</div>\n\
<div class=\"line\">        m_fDensity = fDensity;</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// Precalculating the m_aFaceID and m_aTriangle arrays for the current mesh. This is only needed when the target mesh is not a full quad mesh.</span></div>\n\
<div class=\"line\"><span class=\"keywordtype\">void</span> PtexLayout::PrepareAdjacency( <span class=\"keyword\">const</span> Mesh *pMesh )</div>\n\
<div class=\"line\">{</div>\n\
<div class=\"line\">    <span class=\"comment\">// The m_aFaceID array will containt the ID of the first ptex face which belongs to the given triangle. </span></div>\n\
<div class=\"line\">    <span class=\"comment\">// For example, if a pentagon represented by the triangles 5-6-7 is split into ptex face with the ID of 7-11, then the array will contain values:</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// m_aFaceID[5] = 7     // ID of the first ptex face belongs to this polygon</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// m_aFaceID[6] = -1        // because this is a fake triangle</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// m_aFaceID[7] = -1     // the same</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// m_aFaceID[8] = 12        // this belongs to the next polygon</span></div>\n\
<div class=\"line\">    m_pMesh = pMesh;</div>\n\
<div class=\"line\">    m_aFaceID.resize( pMesh-&gt;FaceCount() );</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> iTFaceID = 0;  <span class=\"comment\">// This is the ID of the current ptex face.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">for</span> ( <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> i = 0; i &lt; pMesh-&gt;FaceCount(); i++ )</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/mudbox_8h.html#a24f4fe4a32c8501c3cae26db72954a30\">MB_ASSERT</a>( !pMesh-&gt;IsFakeTriangle( i ) );</div>\n\
<div class=\"line\">        m_aFaceID[i] = iTFaceID;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// Calculate the sides of the polygon.</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">int</span> s = 3;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">while</span> ( i+1 &lt; pMesh-&gt;FaceCount() &amp;&amp; pMesh-&gt;IsFakeTriangle( i+1 ) )</div>\n\
<div class=\"line\">        {</div>\n\
<div class=\"line\">            i++;</div>\n\
<div class=\"line\">            s++;</div>\n\
<div class=\"line\">            m_aFaceID[i] = 0xffffffff;</div>\n\
<div class=\"line\">        };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// If the polygon is a quad, then a single ptex face will be generated for it, otherwise each corner will get its own ptex face.</span></div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> ( s == 4 )</div>\n\
<div class=\"line\">            iTFaceID++;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">            iTFaceID += <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#ad585a1393cfa368fa9dc3d8ebff640d5\">s</a>;</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Fill the m_aTriangle array, which is the opposite of the m_afaceID array, it contains the index of the triangle which represents</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// the polygon which belongs to the current ptex face. In the same example as above, the array will look like this:</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// m_aTriangle[7] = 5</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// m_aTriangle[8] = 5</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// m_aTriangle[9] = 5</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// m_aTriangle[10] = 5</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// m_aTriangle[11] = 5</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// m_aTriangle[12] = 8  // this belongs to the next polygon</span></div>\n\
<div class=\"line\">    m_aTriangle.fill( 0xffffffff, iTFaceID );</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">for</span> ( <span class=\"keywordtype\">int</span> i = 0; i &lt; m_aFaceID.size(); i++ )</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> ( m_aFaceID[i] != 0xffffffff )</div>\n\
<div class=\"line\">            m_aTriangle[m_aFaceID[i]] = i;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">for</span> ( <span class=\"keywordtype\">int</span> i = 1; i &lt; m_aTriangle.size(); i++ )</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">if</span> ( m_aTriangle[i] == 0xffffffff )</div>\n\
<div class=\"line\">            m_aTriangle[i] = m_aTriangle[i-1];</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This function calculates the adjacency info for an edge of a mudbox triangle. The iSegment parameter controls which part of the</span></div>\n\
<div class=\"line\"><span class=\"comment\">// edge we are interested (0=first half, 1=second half). This function is only needed when the target mesh is not a full quad mesh.</span></div>\n\
<div class=\"line\"><span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> PtexLayout::AdjacentFaceForTriangle( <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> iFaceIndex, <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> iSide, <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> iSegment, <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> &amp;iEdge )<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\"></span>{</div>\n\
<div class=\"line\">    <span class=\"comment\">// Check which is the adjacent triangle (if any)</span></div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/mudbox_8h.html#a4574db3fa92e5236e049b3e67bc51cd9\">MB_ONBUG</a>( iFaceIndex &gt;= m_pMesh-&gt;FaceCount() )</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> 0xffffffff;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> a = m_pMesh-&gt;TriangleAdjacency( iFaceIndex, iSide );</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ( a == 0xffffffff )</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> 0xffffffff;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// And calculate the side count for the polygon the triangle represents.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> t = a/3;</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/mudbox_8h.html#a4574db3fa92e5236e049b3e67bc51cd9\">MB_ONBUG</a>( t &gt;= m_pMesh-&gt;FaceCount() )</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> 0xffffffff; </div>\n\
<div class=\"line\">    <span class=\"keywordflow\">while</span> ( m_pMesh-&gt;IsFakeTriangle( t ) )</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/mudbox_8h.html#a4574db3fa92e5236e049b3e67bc51cd9\">MB_ONBUG</a>( t == 0 )</div>\n\
<div class=\"line\">            return 0xffffffff;</div>\n\
<div class=\"line\">        t--;</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#afdb89eb8f3f04e3f311b84bafe6f7d0d\">h</a> = t+1;</div>\n\
<div class=\"line\">    while ( <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#afdb89eb8f3f04e3f311b84bafe6f7d0d\">h</a> &lt; m_pMesh-&gt;FaceCount() &amp;&amp; m_pMesh-&gt;IsFakeTriangle( <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#afdb89eb8f3f04e3f311b84bafe6f7d0d\">h</a> ) )</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#afdb89eb8f3f04e3f311b84bafe6f7d0d\">h</a>++;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> s = h-t+2;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/mudbox_8h.html#a4574db3fa92e5236e049b3e67bc51cd9\">MB_ONBUG</a>( s &gt;= 16 )</div>\n\
<div class=\"line\">        return 0xffffffff;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Collect vertices of the adjacent polygon into a local array.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> iV[16];</div>\n\
<div class=\"line\">    iV[0] = m_pMesh-&gt;TriangleIndex( t, 0 );</div>\n\
<div class=\"line\">    iV[1] = m_pMesh-&gt;TriangleIndex( t, 1 );</div>\n\
<div class=\"line\">    for ( <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> f = 0; f &lt; s-2; f++ )</div>\n\
<div class=\"line\">        iV[f+2] = m_pMesh-&gt;TriangleIndex( t+f, 2 );</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> iA = m_pMesh-&gt;TriangleIndex( iFaceIndex, (iSide+1)%3 ), iB = m_pMesh-&gt;TriangleIndex( iFaceIndex, (iSide+2)%3 );</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Search which side of the adjacent poly we are.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> as = 0;</div>\n\
<div class=\"line\">    while ( iB != iV[as] &amp;&amp; iA != iV[(as+1)%s] )</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        as++;</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/mudbox_8h.html#a4574db3fa92e5236e049b3e67bc51cd9\">MB_ONBUG</a>( as == s )</div>\n\
<div class=\"line\">            return 0xffffffff;</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Quads are special case, since they are a single ptex face. In this case the iSegment parameter is ignored.</span></div>\n\
<div class=\"line\">    if ( s == 4 )</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        iEdge = as;</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> m_aFaceID[<a name=\"a33\"></a><a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a653819996e713edf9c01a5b564199189\">t</a>];</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// For other polygons, the edge depends on the iSegment value.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ( iSegment )</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        as = (as+1)%s;</div>\n\
<div class=\"line\">        iEdge = 3;</div>\n\
<div class=\"line\">    }</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">else</span></div>\n\
<div class=\"line\">        iEdge = 0;</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">return</span> m_aFaceID[<a class=\"code\" href=\"#!/url=./cpp_ref/_g_lee_8h.html#a653819996e713edf9c01a5b564199189\">t</a>]+as;</div>\n\
<div class=\"line\">};</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\"><span class=\"comment\">// This function calculates the adjacency info for an edge of a ptex face. If the edge is an internal edge of a polygon, the</span></div>\n\
<div class=\"line\"><span class=\"comment\">// function calculates the values directly. In other cases it calls the function AdjacentFaceForTriangle. This function is only </span></div>\n\
<div class=\"line\"><span class=\"comment\">// needed when the target mesh is not a full quad mesh.</span></div>\n\
<div class=\"line\"><span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> PtexLayout::AdjacentFace( <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> iFaceID, <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> iSide, <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> &amp;iEdge )<span class=\"keyword\"> const</span></div>\n\
<div class=\"line\"><span class=\"keyword\"></span>{</div>\n\
<div class=\"line\">    <span class=\"comment\">// Get the index of the triangle which represents the polygon of the ptex face. This must be a real triangle (i.e. the first triangle of </span></div>\n\
<div class=\"line\">    <span class=\"comment\">// that polygon).</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> iFaceIndex = m_aTriangle[iFaceID];</div>\n\
<div class=\"line\">    <a class=\"code\" href=\"#!/url=./cpp_ref/mudbox_8h.html#a4574db3fa92e5236e049b3e67bc51cd9\">MB_ONBUG</a>( m_pMesh-&gt;IsFakeTriangle( iFaceIndex ) )</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> 0xffffffff;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// Calculate the number of sides of that polygon.</span></div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> e = iFaceIndex+1;</div>\n\
<div class=\"line\">    <span class=\"keywordflow\">while</span> ( e &lt; m_pMesh-&gt;FaceCount() &amp;&amp; m_pMesh-&gt;IsFakeTriangle( e ) )</div>\n\
<div class=\"line\">        e++;</div>\n\
<div class=\"line\">    <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> s = e-iFaceIndex+2;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// If the polygon is a quad, there are no internal edges (since all quads are represented as a single ptex face),</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// so we call AdjacentFaceForTriangle. If the other side of the edge contains multiple ptex faces (i.e. it belongs to</span></div>\n\
<div class=\"line\">    <span class=\"comment\">// a polygon which is not a quad), ptex expects the first subface encountered in a counter-clockwise (i.e. edgeid </span></div>\n\
<div class=\"line\">    <span class=\"comment\">// order) traversal of the face as the adjacent face, so we are looking for the second segment of the edge (iSegment=1)</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ( s == 4 )</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> b[4] = { 0, 0, 1, 1 };</div>\n\
<div class=\"line\">        <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> s[4] = { 2, 0, 0, 1 };</div>\n\
<div class=\"line\">        <span class=\"keywordflow\">return</span> AdjacentFaceForTriangle( iFaceIndex+b[iSide], s[iSide], 1, iEdge );</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// When the current polygon is not a quad, then the edges 0 and 3 are external edges (see http://http://ptex.us/adjdata.html </span></div>\n\
<div class=\"line\">    <span class=\"comment\">// for more detail), so in that case we call AdjacentFaceForTriangle with the proper data.</span></div>\n\
<div class=\"line\">    <span class=\"keywordflow\">if</span> ( iSide == 0 || iSide == 3 )</div>\n\
<div class=\"line\">    {</div>\n\
<div class=\"line\">        <span class=\"comment\">// First we calculate which edge of the polygon this ptex edge belongs to.</span></div>\n\
<div class=\"line\">        <span class=\"keywordtype\">unsigned</span> <span class=\"keywordtype\">int</span> l = iFaceID-m_aFaceID[iFaceIndex];</div>\n\
<div class=\"line\">        <a class=\"code\" href=\"#!/url=./cpp_ref/mudbox_8h.html#a4574db3fa92e5236e049b3e67bc51cd9\">MB_ONBUG</a>( l &gt;= 16 )</div>\n\
<div class=\"line\">            return 0xffffffff;</div>\n\
<div class=\"line\">        if ( iSide )</div>\n\
<div class=\"line\">            l = (l+s-1)%s;</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">        <span class=\"comment\">// If it is the first edge, then that is the last edge of the first triangle belongs to the polygon.</span></div>\n\
<div class=\"line\">        if ( l == 0 )</div>\n\
<div class=\"line\">            return AdjacentFaceForTriangle( iFaceIndex, 2, iSide ? 0 : 1, iEdge );</div>\n\
<div class=\"line\">        <span class=\"comment\">// If it is the last edge, then it is the middle edge of the last triangle.</span></div>\n\
<div class=\"line\">        if ( l == s-1 )</div>\n\
<div class=\"line\">            return AdjacentFaceForTriangle( iFaceIndex+s-3, 1, iSide ? 0 : 1, iEdge );</div>\n\
<div class=\"line\">        <span class=\"comment\">// In other cases, it is the first edge of the corresponding triangle.</span></div>\n\
<div class=\"line\">        return AdjacentFaceForTriangle( iFaceIndex+l-1, 0, iSide ? 0 : 1, iEdge );</div>\n\
<div class=\"line\">    };</div>\n\
<div class=\"line\"></div>\n\
<div class=\"line\">    <span class=\"comment\">// When it is an internal edge, the adjacent ptex face will be another subface of the same polygon.</span></div>\n\
<div class=\"line\">    if ( iSide == 2 )</div>\n\
<div class=\"line\">        iEdge = 1;</div>\n\
<div class=\"line\">    else</div>\n\
<div class=\"line\">        iEdge = 2;</div>\n\
<div class=\"line\">    return m_aFaceID[iFaceIndex]+((iFaceID-m_aFaceID[iFaceIndex]+(iSide==2 ? -1 : 1)+s)%s);</div>\n\
<div class=\"line\">};</div>\n\
</div><!-- fragment --> </div><!-- contents -->\n\
</div><!-- doc-content -->\n\
          <div class=\"footer-block\"><a href=\"../html/ac.cmtdialog.htm\" class=\"comments-anchor\" target=\"_blank\"><span class=\"comments-link\">Please send us your comment about this page</span></a></div></div>\n\
   </div></body>\n\
</html>\n\
";