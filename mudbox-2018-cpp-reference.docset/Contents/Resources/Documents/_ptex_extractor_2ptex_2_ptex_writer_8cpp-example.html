<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
<head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><meta content="MOBPRO" name="product"/><meta content="2018" name="release"/><meta content="GeneralUser" name="book"/><meta content="2017-09-08" name="created"/><meta content="GUID-02FA7DD3-6C7A-4C6A-B7BC-824765AE1CB2" name="topicid"/><meta content="concept" name="topic-type"/>
<title>PtexExtractor/ptex/PtexWriter.cpp</title>
</head>
<body height="100%"><div class="body_content" id="body-content"><link href="../style/navtree.css" rel="stylesheet" type="text/css"/><link href="../style/doxygen.css" rel="stylesheet" type="text/css"/><link href="../style/tabs.css" rel="stylesheet" type="text/css"/><link href="../style/adsk.cpm.css" rel="stylesheet" type="text/css"/><script language="javascript">var index = 'index.html';</script><script>$(document).ready(function() { yepnope.injectJs("./scripts/ac_common.js"); });</script><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('_ptex_extractor_2ptex_2_ptex_writer_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type="text/javascript">$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
<div class="Dark" id="MicrosoftTranslatorWidget" style="float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden"></div>
<div>
<div class="head">
<h1>PtexExtractor/ptex/PtexWriter.cpp</h1>
</div>
<div id="top"><!-- Generated by Doxygen 1.8.10 -->
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="./index.html"><span>MainÂ Page</span></a></li>
<li><a href="./pages.html"><span>Topics</span></a></li>
<li><a href="./modules.html"><span>Modules</span></a></li>
<li><a href="./namespaces.html"><span>Namespaces</span></a></li>
<li><a href="./annotated.html"><span>Classes</span></a></li>
<li><a href="./files.html"><span>Files</span></a></li>
<li><a href="./examples.html"><span>Examples</span></a></li>
</ul>
</div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<div id="doc-content">
<div class="header">
<div class="headertitle">
<div class="title">PtexExtractor/ptex/PtexWriter.cpp</div> </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">/* </span></div>
<div class="line"><span class="comment">PTEX SOFTWARE</span></div>
<div class="line"><span class="comment">Copyright 2009 Disney Enterprises, Inc.  All rights reserved</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">Redistribution and use in source and binary forms, with or without</span></div>
<div class="line"><span class="comment">modification, are permitted provided that the following conditions are</span></div>
<div class="line"><span class="comment">met:</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  * Redistributions of source code must retain the above copyright</span></div>
<div class="line"><span class="comment">    notice, this list of conditions and the following disclaimer.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  * Redistributions in binary form must reproduce the above copyright</span></div>
<div class="line"><span class="comment">    notice, this list of conditions and the following disclaimer in</span></div>
<div class="line"><span class="comment">    the documentation and/or other materials provided with the</span></div>
<div class="line"><span class="comment">    distribution.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  * The names "Disney", "Walt Disney Pictures", "Walt Disney Animation</span></div>
<div class="line"><span class="comment">    Studios" or the names of its contributors may NOT be used to</span></div>
<div class="line"><span class="comment">    endorse or promote products derived from this software without</span></div>
<div class="line"><span class="comment">    specific prior written permission from Walt Disney Pictures.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">Disclaimer: THIS SOFTWARE IS PROVIDED BY WALT DISNEY PICTURES AND</span></div>
<div class="line"><span class="comment">CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,</span></div>
<div class="line"><span class="comment">BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS</span></div>
<div class="line"><span class="comment">FOR A PARTICULAR PURPOSE, NONINFRINGEMENT AND TITLE ARE DISCLAIMED.</span></div>
<div class="line"><span class="comment">IN NO EVENT SHALL WALT DISNEY PICTURES, THE COPYRIGHT HOLDER OR</span></div>
<div class="line"><span class="comment">CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span></div>
<div class="line"><span class="comment">EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,</span></div>
<div class="line"><span class="comment">PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span></div>
<div class="line"><span class="comment">PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND BASED ON ANY</span></div>
<div class="line"><span class="comment">THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span></div>
<div class="line"><span class="comment">(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span></div>
<div class="line"><span class="comment">OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">/* Ptex writer classes:</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">   PtexIncrWriter implements "incremental" mode and simply appends</span></div>
<div class="line"><span class="comment">   "edit" blocks to the end of the file.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">   PtexMainWriter implements both writing from scratch and updating</span></div>
<div class="line"><span class="comment">   an existing file, either to add data or to "roll up" previous</span></div>
<div class="line"><span class="comment">   incremental edits.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">   Because the various headers (faceinfo, levelinfo, etc.) are</span></div>
<div class="line"><span class="comment">   variable-length and precede the data, and because the data size</span></div>
<div class="line"><span class="comment">   is not known until it is compressed and written, all data</span></div>
<div class="line"><span class="comment">   are written to a temp file and then copied at the end to the</span></div>
<div class="line"><span class="comment">   final location.  This happens during the "finish" phase.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">   Each time a texture is written to the file, a reduction of the</span></div>
<div class="line"><span class="comment">   texture is also generated and stored.  These reductions are stored</span></div>
<div class="line"><span class="comment">   in a temporary form and recalled later as the resolution levels are</span></div>
<div class="line"><span class="comment">   generated.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">   The final reduction for each face is averaged and stored in the</span></div>
<div class="line"><span class="comment">   const data block.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include "PtexPlatform.h"</span></div>
<div class="line"><span class="preprocessor">#include &lt;errno.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;signal.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include "Ptexture.h"</span></div>
<div class="line"><span class="preprocessor">#include "PtexUtils.h"</span></div>
<div class="line"><span class="preprocessor">#include "PtexWriter.h"</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>{</div>
<div class="line"></div>
<div class="line">    FILE* OpenTempFile(<a name="a0"></a><a class="code" href="./_g_lee_8h.html#ae9ea2d206f76ea82db7a2ea002fdef2f">std::string</a>&amp; tmppath)</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">static</span> Mutex lock;</div>
<div class="line">    AutoMutex locker(lock);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// choose temp dir</span></div>
<div class="line"> <span class="keyword">static</span> <a class="code" href="./_g_lee_8h.html#ae9ea2d206f76ea82db7a2ea002fdef2f">std::string</a> tmpdir;</div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">int</span> initialized = 0;</div>
<div class="line"> <span class="keywordflow">if</span> (!initialized) {</div>
<div class="line">        initialized = 1;</div>
<div class="line"><span class="preprocessor">#ifdef WINDOWS</span></div>
<div class="line"> <span class="comment">// use GetTempPath API (first call determines length of result)</span></div>
<div class="line">        DWORD result = ::GetTempPath(0, _T(<span class="stringliteral">""</span>));</div>
<div class="line"> <span class="keywordflow">if</span> (result &gt; 0) {</div>
<div class="line">        std::vector&lt;TCHAR&gt; tempPath(result + 1);</div>
<div class="line">        result = ::GetTempPath(static_cast&lt;DWORD&gt;(tempPath.size()), &amp;tempPath[0]);</div>
<div class="line"> <span class="keywordflow">if</span> (result &gt; 0 &amp;&amp; result &lt;= tempPath.size())</div>
<div class="line">            tmpdir = <a class="code" href="./_g_lee_8h.html#ae9ea2d206f76ea82db7a2ea002fdef2f">std::string</a>(tempPath.begin(), </div>
<div class="line">                     tempPath.begin() + <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(result));</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">            tmpdir = <span class="stringliteral">"."</span>;</div>
<div class="line">        }</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"> <span class="comment">// try $TEMP or $TMP, use /tmp as last resort</span></div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="./_g_lee_8h.html#a653819996e713edf9c01a5b564199189">t</a> = getenv(<span class="stringliteral">"TEMP"</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (!t) t = getenv(<span class="stringliteral">"TMP"</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (!t) t = <span class="stringliteral">"/tmp"</span>;</div>
<div class="line">        tmpdir = <a name="a1"></a><a class="code" href="./_g_lee_8h.html#a653819996e713edf9c01a5b564199189">t</a>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// build temp path</span></div>
<div class="line"> <span class="keywordflow">if</span> ( !PtexWriter::tempFolder.empty() )</div>
<div class="line">        tmpdir = PtexWriter::tempFolder;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef WINDOWS</span></div>
<div class="line"> <span class="comment">// use process id and counter to make unique filename</span></div>
<div class="line">    std::stringstream <a name="a2"></a><a class="code" href="./_g_lee_8h.html#ad585a1393cfa368fa9dc3d8ebff640d5">s</a>;</div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="./_g_lee_8h.html#a9274fa62feb8371797c4c0312446e333">count</a> = 0;</div>
<div class="line">    s &lt;&lt; tmpdir &lt;&lt; <span class="stringliteral">"/"</span> &lt;&lt; <span class="stringliteral">"PtexTmp"</span> &lt;&lt; getpid() &lt;&lt; <span class="stringliteral">"_"</span> &lt;&lt; ++<a name="a3"></a><a class="code" href="./_g_lee_8h.html#a9274fa62feb8371797c4c0312446e333">count</a>;</div>
<div class="line">    tmppath = s.str();</div>
<div class="line"> <span class="keywordflow">return</span> fopen((<span class="keywordtype">char</span>*) tmppath.c_str(), <span class="stringliteral">"wb+"</span>);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"> <span class="comment">// use mkstemp to open unique file</span></div>
<div class="line">    tmppath = tmpdir + <span class="stringliteral">"/PtexTmpXXXXXX"</span>;</div>
<div class="line"> <span class="keywordtype">int</span> fd = mkstemp((<span class="keywordtype">char</span>*) tmppath.c_str());</div>
<div class="line"> <span class="keywordflow">return</span> fdopen(fd, <span class="stringliteral">"w+"</span>);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <a class="code" href="./_g_lee_8h.html#ae9ea2d206f76ea82db7a2ea002fdef2f">std::string</a> fileError(<span class="keyword">const</span> <span class="keywordtype">char</span>* message, <span class="keyword">const</span> <span class="keywordtype">char</span>* path)</div>
<div class="line">    {</div>
<div class="line">    std::stringstream str;</div>
<div class="line">    str &lt;&lt; message &lt;&lt; path &lt;&lt; <span class="stringliteral">"\n"</span> &lt;&lt; strerror(errno);</div>
<div class="line"> <span class="keywordflow">return</span> str.str();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> checkFormat(Ptex::MeshType mt, Ptex::DataType dt, <span class="keywordtype">int</span> nchannels, <span class="keywordtype">int</span> alphachan,</div>
<div class="line">             Ptex::String&amp; error)</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// check to see if given file attributes are valid</span></div>
<div class="line"> <span class="keywordflow">if</span> (!PtexIO::LittleEndian()) {</div>
<div class="line">        error = <span class="stringliteral">"PtexWriter doesn't currently support big-endian cpu's"</span>;</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (mt &lt; Ptex::mt_triangle || mt &gt; Ptex::mt_quad) {</div>
<div class="line">        error = <span class="stringliteral">"PtexWriter error: Invalid mesh type"</span>;</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (dt &lt; Ptex::dt_uint8 || dt &gt; Ptex::dt_float) {</div>
<div class="line">        error = <span class="stringliteral">"PtexWriter error: Invalid data type"</span>;</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (nchannels &lt;= 0) {</div>
<div class="line">        error = <span class="stringliteral">"PtexWriter error: Invalid number of channels"</span>;</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (alphachan != -1 &amp;&amp; (alphachan &lt; 0 || alphachan &gt;= nchannels)) {</div>
<div class="line">        error = <span class="stringliteral">"PtexWriter error: Invalid alpha channel"</span>;</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexWriter::setTempFolder( <a class="code" href="./_g_lee_8h.html#ae9ea2d206f76ea82db7a2ea002fdef2f">std::string</a> folder )</div>
<div class="line">{</div>
<div class="line">    tempFolder = folder;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="./_g_lee_8h.html#ae9ea2d206f76ea82db7a2ea002fdef2f">std::string</a> PtexWriter::tempFolder;</div>
<div class="line"></div>
<div class="line">PtexWriter* PtexWriter::open(<span class="keyword">const</span> <span class="keywordtype">char</span>* path,</div>
<div class="line">                 Ptex::MeshType mt, Ptex::DataType dt,</div>
<div class="line"> <span class="keywordtype">int</span> nchannels, <span class="keywordtype">int</span> alphachan, <span class="keywordtype">int</span> nfaces,</div>
<div class="line">                 Ptex::String&amp; error, <span class="keywordtype">bool</span> genmipmaps)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!checkFormat(mt, dt, nchannels, alphachan, error))</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line">    PtexMainWriter* <a class="code" href="./_g_lee_8h.html#a775b535bae9cb9131338b1cda0807472">w</a> = <span class="keyword">new</span> PtexMainWriter(path, 0,</div>
<div class="line">                       mt, dt, nchannels, alphachan, nfaces,</div>
<div class="line">                       genmipmaps);</div>
<div class="line"> <a class="code" href="./_g_lee_8h.html#ae9ea2d206f76ea82db7a2ea002fdef2f">std::string</a> errstr;</div>
<div class="line"> <span class="keywordflow">if</span> (!w-&gt;ok(error)) {</div>
<div class="line">    w-&gt;release();</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> <a name="a4"></a><a class="code" href="./_g_lee_8h.html#a775b535bae9cb9131338b1cda0807472">w</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">PtexWriter* PtexWriter::edit(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, <span class="keywordtype">bool</span> incremental,</div>
<div class="line">                 Ptex::MeshType mt, Ptex::DataType dt,</div>
<div class="line"> <span class="keywordtype">int</span> nchannels, <span class="keywordtype">int</span> alphachan, <span class="keywordtype">int</span> nfaces,</div>
<div class="line">                 Ptex::String&amp; error, <span class="keywordtype">bool</span> genmipmaps)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!checkFormat(mt, dt, nchannels, alphachan, error))</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// try to open existing file (it might not exist)</span></div>
<div class="line">    FILE* fp = fopen(path, <span class="stringliteral">"rb+"</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (!fp &amp;&amp; errno != ENOENT) {</div>
<div class="line">    error = fileError(<span class="stringliteral">"Can't open ptex file for update: "</span>, path).c_str();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    PtexWriterBase* w = 0;</div>
<div class="line"> <span class="comment">// use incremental writer iff incremental mode requested and file exists</span></div>
<div class="line"> <span class="keywordflow">if</span> (incremental &amp;&amp; fp) {</div>
<div class="line">    w = <span class="keyword">new</span> PtexIncrWriter(path, fp, mt, dt, nchannels, alphachan, nfaces);</div>
<div class="line">    }</div>
<div class="line"> <span class="comment">// otherwise use main writer</span></div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">    PtexTexture* tex = 0;</div>
<div class="line"> <span class="keywordflow">if</span> (fp) {</div>
<div class="line"> <span class="comment">// got an existing file, close and reopen with PtexReader</span></div>
<div class="line">        fclose(fp);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// open reader for existing file</span></div>
<div class="line">        tex = PtexTexture::open(path, error);</div>
<div class="line"> <span class="keywordflow">if</span> (!tex) <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// make sure header matches</span></div>
<div class="line"> <span class="keywordtype">bool</span> headerMatch = (mt == tex-&gt;meshType() &amp;&amp;</div>
<div class="line">                dt == tex-&gt;dataType() &amp;&amp;</div>
<div class="line">                nchannels == tex-&gt;numChannels() &amp;&amp;</div>
<div class="line">                alphachan == tex-&gt;alphaChannel() &amp;&amp;</div>
<div class="line">                nfaces == tex-&gt;numFaces());</div>
<div class="line"> <span class="keywordflow">if</span> (!headerMatch) {</div>
<div class="line">        std::stringstream str;</div>
<div class="line">        str &lt;&lt; <span class="stringliteral">"PtexWriter::edit error: header doesn't match existing file, "</span></div>
<div class="line">            &lt;&lt; <span class="stringliteral">"conversions not currently supported"</span>;</div>
<div class="line">        error = str.str().c_str();</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    w = <span class="keyword">new</span> PtexMainWriter(path, tex, mt, dt, nchannels, alphachan,</div>
<div class="line">                   nfaces, genmipmaps);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!w-&gt;ok(error)) {</div>
<div class="line">    w-&gt;release();</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./_g_lee_8h.html#a775b535bae9cb9131338b1cda0807472">w</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> PtexWriter::applyEdits(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, Ptex::String&amp; error)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// open reader for existing file</span></div>
<div class="line">    PtexTexture* tex = PtexTexture::open(path, error);</div>
<div class="line"> <span class="keywordflow">if</span> (!tex) <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// see if we have any edits to apply</span></div>
<div class="line"> <span class="keywordflow">if</span> (tex-&gt;hasEdits()) {</div>
<div class="line"> <span class="comment">// create non-incremental writer</span></div>
<div class="line">    PtexWriter* w = <span class="keyword">new</span> PtexMainWriter(path, tex, tex-&gt;meshType(), tex-&gt;dataType(),</div>
<div class="line">                       tex-&gt;numChannels(), tex-&gt;alphaChannel(), tex-&gt;numFaces(),</div>
<div class="line">                       tex-&gt;hasMipMaps());</div>
<div class="line"> <span class="comment">// close to rebuild file</span></div>
<div class="line"> <span class="keywordflow">if</span> (!w-&gt;close(error)) <span class="keywordflow">return</span> 0;</div>
<div class="line">    w-&gt;release();</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">PtexWriterBase::PtexWriterBase(<span class="keyword">const</span> <span class="keywordtype">char</span>* path,</div>
<div class="line">                   Ptex::MeshType mt, Ptex::DataType dt,</div>
<div class="line"> <span class="keywordtype">int</span> nchannels, <span class="keywordtype">int</span> alphachan, <span class="keywordtype">int</span> nfaces,</div>
<div class="line"> <span class="keywordtype">bool</span> compress)</div>
<div class="line">    : _ok(true),</div>
<div class="line">      _path(path),</div>
<div class="line">      _tilefp(0)</div>
<div class="line">{</div>
<div class="line">    memset(&amp;_header, 0, <span class="keyword">sizeof</span>(_header));</div>
<div class="line">    _header.magic = Magic;</div>
<div class="line">    _header.version = PtexFileMajorVersion;</div>
<div class="line">    _header.minorversion = PtexFileMinorVersion;</div>
<div class="line">    _header.meshtype = mt;</div>
<div class="line">    _header.datatype = dt;</div>
<div class="line">    _header.alphachan = alphachan;</div>
<div class="line">    _header.nchannels = nchannels;</div>
<div class="line">    _header.nfaces = nfaces;</div>
<div class="line">    _header.nlevels = 0;</div>
<div class="line">    _header.extheadersize = <span class="keyword">sizeof</span>(_extheader);</div>
<div class="line">    _pixelSize = _header.pixelSize();</div>
<div class="line"></div>
<div class="line">    memset(&amp;_extheader, 0, <span class="keyword">sizeof</span>(_extheader));</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (mt == mt_triangle)</div>
<div class="line">    _reduceFn = &amp;PtexUtils::reduceTri;</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">    _reduceFn = &amp;PtexUtils::reduce;</div>
<div class="line"></div>
<div class="line">    memset(&amp;_zstream, 0, <span class="keyword">sizeof</span>(_zstream));</div>
<div class="line">    deflateInit(&amp;_zstream, compress ? Z_DEFAULT_COMPRESSION : 0);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// create temp file for writing tiles</span></div>
<div class="line"> <span class="comment">// (must compress each tile before assembling a tiled face)</span></div>
<div class="line"> <a class="code" href="./_g_lee_8h.html#ae9ea2d206f76ea82db7a2ea002fdef2f">std::string</a> error;</div>
<div class="line">    _tilefp = OpenTempFile(_tilepath);</div>
<div class="line"> <span class="keywordflow">if</span> (!_tilefp) {</div>
<div class="line">    setError(fileError(<span class="stringliteral">"Error creating temp file: "</span>, _tilepath.c_str()));</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexWriterBase::release()</div>
<div class="line">{</div>
<div class="line">    Ptex::String error;</div>
<div class="line"> <span class="comment">// close writer if app didn't, and report error if any</span></div>
<div class="line"> <span class="keywordflow">if</span> (_tilefp &amp;&amp; !close(error))</div>
<div class="line">    std::cerr &lt;&lt; error.c_str() &lt;&lt; <a name="a5"></a><a class="code" href="./qtextstream_8h.html#ad61c42fcbf3cb355a75ddd5216d12ace">std::endl</a>;</div>
<div class="line"> <span class="keyword">delete</span> <span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">PtexWriterBase::~PtexWriterBase()</div>
<div class="line">{</div>
<div class="line">    deflateEnd(&amp;_zstream);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> PtexWriterBase::close(Ptex::String&amp; error)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (_ok) finish();</div>
<div class="line"> <span class="keywordflow">if</span> (!_ok) getError(error);</div>
<div class="line"> <span class="keywordflow">if</span> (_tilefp) {</div>
<div class="line">    fclose(_tilefp);</div>
<div class="line">    unlink(_tilepath.c_str());</div>
<div class="line">    _tilefp = 0;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> _ok;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> PtexWriterBase::storeFaceInfo(<span class="keywordtype">int</span> faceid, FaceInfo&amp; <a class="code" href="./_g_lee_8h.html#a691492ec0bd6383f91200e49f6ae40ed">f</a>, <span class="keyword">const</span> FaceInfo&amp; <a class="code" href="./_g_lee_8h.html#a72e0fdf0f845ded60b1fada9e9195cd7">src</a>, <span class="keywordtype">int</span> flags)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (faceid &lt; 0 || <span class="keywordtype">size_t</span>(faceid) &gt;= _header.nfaces) {</div>
<div class="line">    setError(<span class="stringliteral">"PtexWriter error: faceid out of range"</span>);</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (_header.meshtype == mt_triangle &amp;&amp; (f.res.ulog2 != f.res.vlog2)) {</div>
<div class="line">    setError(<span class="stringliteral">"PtexWriter error: asymmetric face res not supported for triangle textures"</span>);</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// copy all values</span></div>
<div class="line">    f = <a name="a6"></a><a class="code" href="./_g_lee_8h.html#a72e0fdf0f845ded60b1fada9e9195cd7">src</a>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// and clear extraneous ones</span></div>
<div class="line"> <span class="keywordflow">if</span> (_header.meshtype == mt_triangle) {</div>
<div class="line">    f.flags = 0; <span class="comment">// no user-settable flags on triangles</span></div>
<div class="line">    f.adjfaces[3] = -1;</div>
<div class="line">    f.adjedges &amp;= 0x3f; <span class="comment">// clear all but bottom six bits</span></div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// clear non-user-settable flags</span></div>
<div class="line">    f.flags &amp;= FaceInfo::flag_subface;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// set new flags</span></div>
<div class="line">    f.flags |= flags;</div>
<div class="line"> <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexWriterBase::writeMeta(<span class="keyword">const</span> <span class="keywordtype">char</span>* key, <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="./_g_lee_8h.html#aed27f17ebdc1fd207871bc2ed5da0d0f">value</a>)</div>
<div class="line">{</div>
<div class="line">    addMetaData(key, mdt_string, value, <span class="keywordtype">int</span>(strlen(value)+1));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexWriterBase::writeMeta(<span class="keyword">const</span> <span class="keywordtype">char</span>* key, <span class="keyword">const</span> int8_t* value, <span class="keywordtype">int</span> <a class="code" href="./_g_lee_8h.html#a9274fa62feb8371797c4c0312446e333">count</a>)</div>
<div class="line">{</div>
<div class="line">    addMetaData(key, mdt_int8, value, count);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexWriterBase::writeMeta(<span class="keyword">const</span> <span class="keywordtype">char</span>* key, <span class="keyword">const</span> int16_t* value, <span class="keywordtype">int</span> <a class="code" href="./_g_lee_8h.html#a9274fa62feb8371797c4c0312446e333">count</a>)</div>
<div class="line">{</div>
<div class="line">    addMetaData(key, mdt_int16, value, count*<span class="keyword">sizeof</span>(int16_t));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexWriterBase::writeMeta(<span class="keyword">const</span> <span class="keywordtype">char</span>* key, <span class="keyword">const</span> int32_t* value, <span class="keywordtype">int</span> count)</div>
<div class="line">{</div>
<div class="line">    addMetaData(key, mdt_int32, value, count*<span class="keyword">sizeof</span>(int32_t));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexWriterBase::writeMeta(<span class="keyword">const</span> <span class="keywordtype">char</span>* key, <span class="keyword">const</span> <span class="keywordtype">float</span>* value, <span class="keywordtype">int</span> count)</div>
<div class="line">{</div>
<div class="line">    addMetaData(key, mdt_float, value, count*<span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexWriterBase::writeMeta(<span class="keyword">const</span> <span class="keywordtype">char</span>* key, <span class="keyword">const</span> <span class="keywordtype">double</span>* value, <span class="keywordtype">int</span> count)</div>
<div class="line">{</div>
<div class="line">    addMetaData(key, mdt_double, value, count*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexWriterBase::writeMeta(PtexMetaData* <a class="code" href="./_g_lee_8h.html#a2cc7c8468af76cf855e1755c27945693">data</a>)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">int</span> nkeys = data-&gt;numKeys();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nkeys; i++) {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">char</span>* key = 0;</div>
<div class="line">    MetaDataType <a name="a7"></a><a class="code" href="./_g_lee_8h.html#a63267399cd2a2ee217572c11d2e54f07">type</a>;</div>
<div class="line">    data-&gt;getKey(i, key, type);</div>
<div class="line"> <span class="keywordtype">int</span> <a class="code" href="./_g_lee_8h.html#a9274fa62feb8371797c4c0312446e333">count</a>;</div>
<div class="line"> <span class="keywordflow">switch</span> (type) {</div>
<div class="line"> <span class="keywordflow">case</span> mdt_string:</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">char</span>* val=0;</div>
<div class="line">        data-&gt;getValue(key, val);</div>
<div class="line">        writeMeta(key, val);</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> mdt_int8:</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> int8_t* val=0;</div>
<div class="line">        data-&gt;getValue(key, val, count);</div>
<div class="line">        writeMeta(key, val, count);</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> mdt_int16:</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> int16_t* val=0;</div>
<div class="line">        data-&gt;getValue(key, val, count);</div>
<div class="line">        writeMeta(key, val, count);</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> mdt_int32:</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> int32_t* val=0;</div>
<div class="line">        data-&gt;getValue(key, val, count);</div>
<div class="line">        writeMeta(key, val, count);</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> mdt_float:</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">float</span>* val=0;</div>
<div class="line">        data-&gt;getValue(key, val, count);</div>
<div class="line">        writeMeta(key, val, count);</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> mdt_double:</div>
<div class="line">        {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">double</span>* val=0;</div>
<div class="line">        data-&gt;getValue(key, val, count);</div>
<div class="line">        writeMeta(key, val, count);</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexWriterBase::addMetaData(<span class="keyword">const</span> <span class="keywordtype">char</span>* key, MetaDataType <a class="code" href="./_g_lee_8h.html#a653819996e713edf9c01a5b564199189">t</a>,</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">void</span>* value, <span class="keywordtype">int</span> <a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (strlen(key) &gt; 255) {</div>
<div class="line">    std::stringstream str;</div>
<div class="line">    str &lt;&lt; <span class="stringliteral">"PtexWriter error: meta data key too long (max=255) \""</span> &lt;&lt; key &lt;&lt; <span class="stringliteral">"\""</span>;</div>
<div class="line">    setError(str.str());</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (size &lt;= 0) {</div>
<div class="line">    std::stringstream str;</div>
<div class="line">    str &lt;&lt; <span class="stringliteral">"PtexWriter error: meta data size &lt;= 0 for \""</span> &lt;&lt; key &lt;&lt; <span class="stringliteral">"\""</span>;</div>
<div class="line">    setError(str.str());</div>
<div class="line">    }</div>
<div class="line">    std::map&lt;std::string,int&gt;::iterator iter = _metamap.find(key);</div>
<div class="line"> <span class="keywordtype">int</span> <a name="a8"></a><a class="code" href="./_g_lee_8h.html#a6468fe3bfff24d7d939eb21863b88268">index</a>;</div>
<div class="line"> <span class="keywordflow">if</span> (iter != _metamap.end()) {</div>
<div class="line"> <span class="comment">// see if we already have this entry - if so, overwrite it</span></div>
<div class="line">    index = iter-&gt;second;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// allocate a new entry</span></div>
<div class="line">    index = _metadata.size();</div>
<div class="line">    _metadata.resize(index+1);</div>
<div class="line">    _metamap[key] = <a class="code" href="./_g_lee_8h.html#a6468fe3bfff24d7d939eb21863b88268">index</a>;</div>
<div class="line">    }</div>
<div class="line">    MetaEntry&amp; m = _metadata[<a class="code" href="./_g_lee_8h.html#a6468fe3bfff24d7d939eb21863b88268">index</a>];</div>
<div class="line">    m.key = key;</div>
<div class="line">    m.datatype = <a class="code" href="./_g_lee_8h.html#a653819996e713edf9c01a5b564199189">t</a>;</div>
<div class="line">    m.data.resize(size);</div>
<div class="line">    memcpy(&amp;m.data[0], value, size);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> PtexWriterBase::writeBlank(FILE* fp, <span class="keywordtype">int</span> size)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!_ok) <span class="keywordflow">return</span> 0;</div>
<div class="line"> <span class="keyword">static</span> <span class="keywordtype">char</span> zeros[BlockSize] = {0};</div>
<div class="line"> <span class="keywordtype">int</span> remain = <a name="a9"></a><a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>;</div>
<div class="line"> <span class="keywordflow">while</span> (remain &gt; 0) {</div>
<div class="line">    remain -= writeBlock(fp, zeros, remain &lt; BlockSize ? remain : BlockSize);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> PtexWriterBase::writeBlock(FILE* fp, <span class="keyword">const</span> <span class="keywordtype">void</span>* data, <span class="keywordtype">int</span> size)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!_ok) <span class="keywordflow">return</span> 0;</div>
<div class="line"> <span class="keywordflow">if</span> (!fwrite(data, size, 1, fp)) {</div>
<div class="line">    setError(<span class="stringliteral">"PtexWriter error: file write failed"</span>);</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> PtexWriterBase::writeZipBlock(FILE* fp, <span class="keyword">const</span> <span class="keywordtype">void</span>* data, <span class="keywordtype">int</span> size, <span class="keywordtype">bool</span> finish)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!_ok) <span class="keywordflow">return</span> 0;</div>
<div class="line"> <span class="keywordtype">void</span>* buff = alloca(BlockSize);</div>
<div class="line">    _zstream.next_in = (Bytef*)data;</div>
<div class="line">    _zstream.avail_in = <a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">while</span> (1) {</div>
<div class="line">    _zstream.next_out = (Bytef*)buff;</div>
<div class="line">    _zstream.avail_out = BlockSize;</div>
<div class="line"> <span class="keywordtype">int</span> zresult = deflate(&amp;_zstream, finish ? Z_FINISH : Z_NO_FLUSH);</div>
<div class="line"> <span class="keywordtype">int</span> size = BlockSize - _zstream.avail_out;</div>
<div class="line"> <span class="keywordflow">if</span> (size &gt; 0) writeBlock(fp, buff, size);</div>
<div class="line"> <span class="keywordflow">if</span> (zresult == Z_STREAM_END) <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">if</span> (zresult != Z_OK) {</div>
<div class="line">        setError(<span class="stringliteral">"PtexWriter error: data compression internal error"</span>);</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (!finish &amp;&amp; _zstream.avail_out != 0)</div>
<div class="line"> <span class="comment">// waiting for more input</span></div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!finish) <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> total = _zstream.total_out;</div>
<div class="line">    deflateReset(&amp;_zstream);</div>
<div class="line"> <span class="keywordflow">return</span> total;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> PtexWriterBase::readBlock(FILE* fp, <span class="keywordtype">void</span>* data, <span class="keywordtype">int</span> size)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!fread(data, size, 1, fp)) {</div>
<div class="line">    setError(<span class="stringliteral">"PtexWriter error: temp file read failed"</span>);</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> PtexWriterBase::copyBlock(FILE* <a class="code" href="./_g_lee_8h.html#a92034251bfd455d524a9b5610cddba00">dst</a>, FILE* src, FilePos pos, <span class="keywordtype">int</span> size)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (size &lt;= 0) <span class="keywordflow">return</span> 0;</div>
<div class="line">    fseeko(src, pos, SEEK_SET);</div>
<div class="line"> <span class="keywordtype">int</span> remain = <a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>;</div>
<div class="line"> <span class="keywordtype">void</span>* buff = alloca(BlockSize);</div>
<div class="line"> <span class="keywordflow">while</span> (remain) {</div>
<div class="line"> <span class="keywordtype">int</span> nbytes = remain &lt; BlockSize ? remain : BlockSize;</div>
<div class="line"> <span class="keywordflow">if</span> (!fread(buff, nbytes, 1, src)) {</div>
<div class="line">        setError(<span class="stringliteral">"PtexWriter error: temp file read failed"</span>);</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (!writeBlock(dst, buff, nbytes)) <span class="keywordflow">break</span>;</div>
<div class="line">    remain -= nbytes;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">Ptex::Res PtexWriterBase::calcTileRes(Res faceres)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// desired number of tiles = floor(log2(facesize / tilesize))</span></div>
<div class="line"> <span class="keywordtype">int</span> facesize = faceres.size() * _pixelSize;</div>
<div class="line"> <span class="keywordtype">int</span> ntileslog2 = PtexUtils::floor_log2(facesize/TileSize);</div>
<div class="line"> <span class="keywordflow">if</span> (ntileslog2 == 0) <span class="keywordflow">return</span> faceres;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// number of tiles is defined as:</span></div>
<div class="line"> <span class="comment">//   ntileslog2 = ureslog2 + vreslog2 - (tile_ureslog2 + tile_vreslog2)</span></div>
<div class="line"> <span class="comment">// rearranging to solve for the tile res:</span></div>
<div class="line"> <span class="comment">//   tile_ureslog2 + tile_vreslog2 = ureslog2 + vreslog2 - ntileslog2</span></div>
<div class="line"> <span class="keywordtype">int</span> <a class="code" href="./_g_lee_8h.html#a830e6eb5d1b77f7226a78592ba9d2613">n</a> = faceres.ulog2 + faceres.vlog2 - ntileslog2;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// choose u and v sizes for roughly square result (u ~= v ~= n/2)</span></div>
<div class="line"> <span class="comment">// and make sure tile isn't larger than face</span></div>
<div class="line">    Res tileres;</div>
<div class="line">    tileres.ulog2 = PtexUtils::min((n+1)/2, <span class="keywordtype">int</span>(faceres.ulog2));</div>
<div class="line">    tileres.vlog2 = PtexUtils::min(n - tileres.ulog2, <span class="keywordtype">int</span>(faceres.vlog2));</div>
<div class="line"> <span class="keywordflow">return</span> tileres;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexWriterBase::writeConstFaceBlock(FILE* fp, <span class="keyword">const</span> <span class="keywordtype">void</span>* data,</div>
<div class="line">                     FaceDataHeader&amp; fdh)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// write a single const face data block</span></div>
<div class="line"> <span class="comment">// record level data for face and output the one pixel value</span></div>
<div class="line">    fdh.set(_pixelSize, enc_constant);</div>
<div class="line">    writeBlock(fp, data, _pixelSize);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexWriterBase::writeFaceBlock(FILE* fp, <span class="keyword">const</span> <span class="keywordtype">void</span>* data, <span class="keywordtype">int</span> <a class="code" href="./_g_lee_8h.html#a9d21c1b0530d07b637b5b71b969d7921">stride</a>,</div>
<div class="line">                    Res <a class="code" href="./_g_lee_8h.html#a1dbb21208b9047cc8031ca9c840d3c2f">res</a>, FaceDataHeader&amp; fdh)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// write a single face data block</span></div>
<div class="line"> <span class="comment">// copy to temp buffer, and deinterleave</span></div>
<div class="line"> <span class="keywordtype">int</span> ures = res.u(), vres = res.v();</div>
<div class="line"> <span class="keywordtype">int</span> blockSize = ures*vres*_pixelSize;</div>
<div class="line"> <span class="keywordtype">bool</span> useMalloc = blockSize &gt; AllocaMax;</div>
<div class="line"> <span class="keywordtype">char</span>* buff = useMalloc ? (<span class="keywordtype">char</span>*) malloc(blockSize) : (char*)alloca(blockSize);</div>
<div class="line">    PtexUtils::deinterleave(data, stride, ures, vres, buff,</div>
<div class="line">                ures*DataSize(_header.datatype),</div>
<div class="line">                _header.datatype, _header.nchannels);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// difference if needed</span></div>
<div class="line"> <span class="keywordtype">bool</span> diff = (_header.datatype == dt_uint8 ||</div>
<div class="line">         _header.datatype == dt_uint16);</div>
<div class="line"> <span class="keywordflow">if</span> (diff) PtexUtils::encodeDifference(buff, blockSize, _header.datatype);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// compress and stream data to file, and record size in header</span></div>
<div class="line"> <span class="keywordtype">int</span> zippedsize = writeZipBlock(fp, buff, blockSize);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// record compressed size and encoding in data header</span></div>
<div class="line">    fdh.set(zippedsize, diff ? enc_diffzipped : enc_zipped);</div>
<div class="line"> <span class="keywordflow">if</span> (useMalloc) free(buff);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexWriterBase::writeFaceData(FILE* fp, <span class="keyword">const</span> <span class="keywordtype">void</span>* data, <span class="keywordtype">int</span> stride,</div>
<div class="line">                   Res res, FaceDataHeader&amp; fdh)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// determine whether to break into tiles</span></div>
<div class="line">    Res tileres = calcTileRes(res);</div>
<div class="line"> <span class="keywordtype">int</span> ntilesu = res.ntilesu(tileres);</div>
<div class="line"> <span class="keywordtype">int</span> ntilesv = res.ntilesv(tileres);</div>
<div class="line"> <span class="keywordtype">int</span> ntiles = ntilesu * ntilesv;</div>
<div class="line"> <span class="keywordflow">if</span> (ntiles == 1) {</div>
<div class="line"> <span class="comment">// write single block</span></div>
<div class="line">    writeFaceBlock(fp, data, stride, res, fdh);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// write tiles to tilefp temp file</span></div>
<div class="line">    rewind(_tilefp);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// alloc tile header</span></div>
<div class="line">    std::vector&lt;FaceDataHeader&gt; tileHeader(ntiles);</div>
<div class="line"> <span class="keywordtype">int</span> tileures = tileres.u();</div>
<div class="line"> <span class="keywordtype">int</span> tilevres = tileres.v();</div>
<div class="line"> <span class="keywordtype">int</span> tileustride = tileures*_pixelSize;</div>
<div class="line"> <span class="keywordtype">int</span> tilevstride = tilevres*<a name="a10"></a><a class="code" href="./_g_lee_8h.html#a9d21c1b0530d07b637b5b71b969d7921">stride</a>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// output tiles</span></div>
<div class="line">    FaceDataHeader* tdh = &amp;tileHeader[0];</div>
<div class="line"> <span class="keywordtype">int</span> datasize = 0;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">char</span>* rowp = (<span class="keyword">const</span> <span class="keywordtype">char</span>*) data;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">char</span>* rowpend = rowp + ntilesv * tilevstride;</div>
<div class="line"> <span class="keywordflow">for</span> (; rowp != rowpend; rowp += tilevstride) {</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="./_g_lee_8h.html#aa5367c14d90f462230c2611b81b41d23">p</a> = rowp;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">char</span>* pend = p + ntilesu * tileustride;</div>
<div class="line"> <span class="keywordflow">for</span> (; p != pend; tdh++, p += tileustride) {</div>
<div class="line"> <span class="comment">// determine if tile is constant</span></div>
<div class="line"> <span class="keywordflow">if</span> (PtexUtils::isConstant(p, stride, tileures, tilevres, _pixelSize))</div>
<div class="line">            writeConstFaceBlock(_tilefp, p, *tdh);</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">            writeFaceBlock(_tilefp, p, stride, tileres, *tdh);</div>
<div class="line">        datasize += tdh-&gt;blocksize();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// output compressed tile header</span></div>
<div class="line">    uint32_t tileheadersize = writeZipBlock(_tilefp, &amp;tileHeader[0],</div>
<div class="line"> <span class="keywordtype">int</span>(<span class="keyword">sizeof</span>(FaceDataHeader)*tileHeader.size()));</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="comment">// output tile data pre-header</span></div>
<div class="line"> <span class="keywordtype">int</span> totalsize = 0;</div>
<div class="line">    totalsize += writeBlock(fp, &amp;tileres, <span class="keyword">sizeof</span>(Res));</div>
<div class="line">    totalsize += writeBlock(fp, &amp;tileheadersize, <span class="keyword">sizeof</span>(tileheadersize));</div>
<div class="line"></div>
<div class="line"> <span class="comment">// copy compressed tile header from temp file</span></div>
<div class="line">    totalsize += copyBlock(fp, _tilefp, datasize, tileheadersize);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// copy tile data from temp file</span></div>
<div class="line">    totalsize += copyBlock(fp, _tilefp, 0, datasize);</div>
<div class="line"></div>
<div class="line">    fdh.set(totalsize, enc_tiled);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexWriterBase::writeReduction(FILE* fp, <span class="keyword">const</span> <span class="keywordtype">void</span>* data, <span class="keywordtype">int</span> stride, Res res)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// reduce and write to file</span></div>
<div class="line">    Ptex::Res newres(res.ulog2-1, res.vlog2-1);</div>
<div class="line"> <span class="keywordtype">int</span> buffsize = newres.size() * _pixelSize;</div>
<div class="line"> <span class="keywordtype">bool</span> useMalloc = buffsize &gt; AllocaMax;</div>
<div class="line"> <span class="keywordtype">char</span>* buff = useMalloc ? (<span class="keywordtype">char</span>*) malloc(buffsize) : (char*)alloca(buffsize);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> dstride = newres.u() * _pixelSize;</div>
<div class="line">    _reduceFn(data, stride, res.u(), res.v(), buff, dstride, _header.datatype, _header.nchannels);</div>
<div class="line">    writeBlock(fp, buff, buffsize);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (useMalloc) free(buff);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> PtexWriterBase::writeMetaDataBlock(FILE* fp, MetaEntry&amp; val)</div>
<div class="line">{</div>
<div class="line">    uint8_t keysize = uint8_t(val.key.size()+1);</div>
<div class="line">    uint8_t datatype = val.datatype;</div>
<div class="line">    uint32_t datasize = uint32_t(val.data.size());</div>
<div class="line">    writeZipBlock(fp, &amp;keysize, <span class="keyword">sizeof</span>(keysize), <span class="keyword">false</span>);</div>
<div class="line">    writeZipBlock(fp, val.key.c_str(), keysize, <span class="keyword">false</span>);</div>
<div class="line">    writeZipBlock(fp, &amp;datatype, <span class="keyword">sizeof</span>(datatype), <span class="keyword">false</span>);</div>
<div class="line">    writeZipBlock(fp, &amp;datasize, <span class="keyword">sizeof</span>(datasize), <span class="keyword">false</span>);</div>
<div class="line">    writeZipBlock(fp, &amp;val.data[0], datasize, <span class="keyword">false</span>);</div>
<div class="line"> <span class="keywordtype">int</span> memsize = (<span class="keyword">sizeof</span>(keysize) + keysize + <span class="keyword">sizeof</span>(datatype)</div>
<div class="line">           + <span class="keyword">sizeof</span>(datasize) + datasize);</div>
<div class="line"> <span class="keywordflow">return</span> memsize;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">PtexMainWriter::PtexMainWriter(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, PtexTexture* tex,</div>
<div class="line">                   Ptex::MeshType mt, Ptex::DataType dt,</div>
<div class="line"> <span class="keywordtype">int</span> nchannels, <span class="keywordtype">int</span> alphachan, <span class="keywordtype">int</span> nfaces, <span class="keywordtype">bool</span> genmipmaps)</div>
<div class="line">    : PtexWriterBase(path, mt, dt, nchannels, alphachan, nfaces,</div>
<div class="line"> <span class="comment">/* compress */</span> true),</div>
<div class="line">      _hasNewData(false),</div>
<div class="line">      _genmipmaps(genmipmaps),</div>
<div class="line">      _reader(0)</div>
<div class="line">{</div>
<div class="line">    _tmpfp = OpenTempFile(_tmppath);</div>
<div class="line"> <span class="keywordflow">if</span> (!_tmpfp) {</div>
<div class="line">    setError(fileError(<span class="stringliteral">"Error creating temp file: "</span>, _tmppath.c_str()));</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// data will be written to a ".new" path and then renamed to final location</span></div>
<div class="line">    _newpath = path; _newpath += <span class="stringliteral">".new"</span>;</div>
<div class="line"></div>
<div class="line">    _levels.reserve(20);</div>
<div class="line">    _levels.resize(1);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// init faceinfo and set flags to -1 to mark as uninitialized</span></div>
<div class="line">    _faceinfo.resize(nfaces);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nfaces; i++) _faceinfo[i].flags = uint8_t(-1);</div>
<div class="line"></div>
<div class="line">    _levels.front().pos.resize(nfaces);</div>
<div class="line">    _levels.front().fdh.resize(nfaces);</div>
<div class="line">    _rpos.resize(nfaces);</div>
<div class="line">    _constdata.resize(nfaces*_pixelSize);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (tex) {</div>
<div class="line"> <span class="comment">// access reader implementation</span></div>
<div class="line">    _reader = <span class="keyword">dynamic_cast&lt;</span>PtexReader*<span class="keyword">&gt;</span>(tex);</div>
<div class="line"> <span class="keywordflow">if</span> (!_reader) {</div>
<div class="line">        setError(<span class="stringliteral">"Internal error: dynamic_cast&lt;PtexReader*&gt; failed"</span>);</div>
<div class="line">        tex-&gt;release();</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// copy border modes</span></div>
<div class="line">    setBorderModes(tex-&gt;uBorderMode(), tex-&gt;vBorderMode());</div>
<div class="line"></div>
<div class="line"> <span class="comment">// copy meta data from existing file</span></div>
<div class="line">    PtexPtr&lt;PtexMetaData&gt; meta ( _reader-&gt;getMetaData() );</div>
<div class="line">    writeMeta(meta);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// see if we have any edits</span></div>
<div class="line">    _hasNewData = _reader-&gt;hasEdits();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">PtexMainWriter::~PtexMainWriter()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (_reader) _reader-&gt;release();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> PtexMainWriter::close(Ptex::String&amp; error)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// closing base writer will write all pending data via finish() method</span></div>
<div class="line"> <span class="comment">// and will close _fp (which in this case is on the temp disk)</span></div>
<div class="line"> <span class="keywordtype">bool</span> result = PtexWriterBase::close(error);</div>
<div class="line"> <span class="keywordflow">if</span> (_reader) {</div>
<div class="line">    _reader-&gt;release();</div>
<div class="line">    _reader = 0;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (_tmpfp) {</div>
<div class="line">    fclose(_tmpfp);</div>
<div class="line">    unlink(_tmppath.c_str());</div>
<div class="line">    _tmpfp = 0;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (result &amp;&amp; _hasNewData) {</div>
<div class="line"> <span class="comment">// rename temppath into final location</span></div>
<div class="line">    unlink(_path.c_str());</div>
<div class="line"> <span class="keywordflow">if</span> (rename(_newpath.c_str(), _path.c_str()) == -1) {</div>
<div class="line">        error = fileError(<span class="stringliteral">"Can't write to ptex file: "</span>, _path.c_str()).c_str();</div>
<div class="line">        unlink(_newpath.c_str());</div>
<div class="line">        result = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> PtexMainWriter::writeFace(<span class="keywordtype">int</span> faceid, <span class="keyword">const</span> FaceInfo&amp; f, <span class="keyword">const</span> <span class="keywordtype">void</span>* data, <span class="keywordtype">int</span> stride)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!_ok) <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// auto-compute stride</span></div>
<div class="line"> <span class="keywordflow">if</span> (stride == 0) stride = f.res.u()*_pixelSize;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// handle constant case</span></div>
<div class="line"> <span class="keywordflow">if</span> (PtexUtils::isConstant(data, stride, f.res.u(), f.res.v(), _pixelSize))</div>
<div class="line"> <span class="keywordflow">return</span> writeConstantFace(faceid, f, data);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// non-constant case, ...</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// check and store face info</span></div>
<div class="line"> <span class="keywordflow">if</span> (!storeFaceInfo(faceid, _faceinfo[faceid], f)) <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// record position of current face</span></div>
<div class="line">    _levels.front().pos[faceid] = ftello(_tmpfp);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// write face data</span></div>
<div class="line">    writeFaceData(_tmpfp, data, stride, f.res, _levels.front().fdh[faceid]);</div>
<div class="line"> <span class="keywordflow">if</span> (!_ok) <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// premultiply (if needed) before making reductions; use temp copy of data</span></div>
<div class="line">    uint8_t* temp = 0;</div>
<div class="line"> <span class="keywordflow">if</span> (_header.hasAlpha()) {</div>
<div class="line"> <span class="comment">// first copy to temp buffer</span></div>
<div class="line"> <span class="keywordtype">int</span> rowlen = f.res.u() * _pixelSize, nrows = f.res.v();</div>
<div class="line">    temp = (uint8_t*) malloc(rowlen * nrows);</div>
<div class="line">    PtexUtils::copy(data, stride, temp, rowlen, nrows, rowlen);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// multiply alpha</span></div>
<div class="line">    PtexUtils::multalpha(temp, f.res.size(), _header.datatype, _header.nchannels,</div>
<div class="line">                 _header.alphachan);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// override source buffer</span></div>
<div class="line">    data = temp;</div>
<div class="line">    stride = rowlen;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// generate first reduction (if needed)</span></div>
<div class="line"> <span class="keywordflow">if</span> (_genmipmaps &amp;&amp;</div>
<div class="line">    (f.res.ulog2 &gt; MinReductionLog2 &amp;&amp; f.res.vlog2 &gt; MinReductionLog2))</div>
<div class="line">    {</div>
<div class="line">    _rpos[faceid] = ftello(_tmpfp);</div>
<div class="line">    writeReduction(_tmpfp, data, stride, f.res);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">    storeConstValue(faceid, data, stride, f.res);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (temp) free(temp);</div>
<div class="line">    _hasNewData = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> PtexMainWriter::writeConstantFace(<span class="keywordtype">int</span> faceid, <span class="keyword">const</span> FaceInfo&amp; f, <span class="keyword">const</span> <span class="keywordtype">void</span>* data)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!_ok) <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// check and store face info</span></div>
<div class="line"> <span class="keywordflow">if</span> (!storeFaceInfo(faceid, _faceinfo[faceid], f, FaceInfo::flag_constant)) <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// store face value in constant block</span></div>
<div class="line">    memcpy(&amp;_constdata[faceid*_pixelSize], data, _pixelSize);</div>
<div class="line">    _hasNewData = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexMainWriter::storeConstValue(<span class="keywordtype">int</span> faceid, <span class="keyword">const</span> <span class="keywordtype">void</span>* data, <span class="keywordtype">int</span> stride, Res res)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// compute average value and store in _constdata block</span></div>
<div class="line">    uint8_t* constdata = &amp;_constdata[faceid*_pixelSize];</div>
<div class="line">    PtexUtils::average(data, stride, res.u(), res.v(), constdata,</div>
<div class="line">               _header.datatype, _header.nchannels);</div>
<div class="line"> <span class="keywordflow">if</span> (_header.hasAlpha())</div>
<div class="line">    PtexUtils::divalpha(constdata, 1, _header.datatype, _header.nchannels, _header.alphachan);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexMainWriter::finish()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// do nothing if there's no new data to write</span></div>
<div class="line"> <span class="keywordflow">if</span> (!_hasNewData) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// copy missing faces from _reader</span></div>
<div class="line"> <span class="keywordflow">if</span> (_reader) {</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0, nfaces = _header.nfaces; i &lt; nfaces; i++) {</div>
<div class="line"> <span class="keywordflow">if</span> (_faceinfo[i].flags == uint8_t(-1)) {</div>
<div class="line"> <span class="comment">// copy face data</span></div>
<div class="line"> <span class="keyword">const</span> Ptex::FaceInfo&amp; info = _reader-&gt;getFaceInfo(i);</div>
<div class="line"> <span class="keywordtype">int</span> size = _pixelSize * info.res.size();</div>
<div class="line"> <span class="keywordflow">if</span> (info.isConstant()) {</div>
<div class="line">                    PtexPtr&lt;PtexFaceData&gt; <a name="a11"></a><a class="code" href="./_g_lee_8h.html#a2cc7c8468af76cf855e1755c27945693">data</a> ( _reader-&gt;getData(i) );</div>
<div class="line"> <span class="keywordflow">if</span> (data) {</div>
<div class="line">                        writeConstantFace(i, info, data-&gt;getData());</div>
<div class="line">                    }</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="keywordtype">void</span>* data = malloc(size);</div>
<div class="line">                    _reader-&gt;getData(i, data, 0);</div>
<div class="line">                    writeFace(i, info, data, 0);</div>
<div class="line">                    free(data);</div>
<div class="line">                }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// just flag missing faces as constant (black)</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0, nfaces = _header.nfaces; i &lt; nfaces; i++) {</div>
<div class="line"> <span class="keywordflow">if</span> (_faceinfo[i].flags == uint8_t(-1))</div>
<div class="line">        _faceinfo[i].flags = FaceInfo::flag_constant;</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// write reductions to tmp file</span></div>
<div class="line"> <span class="keywordflow">if</span> (_genmipmaps)</div>
<div class="line">    generateReductions();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// flag faces w/ constant neighborhoods</span></div>
<div class="line">    flagConstantNeighorhoods();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// update header</span></div>
<div class="line">    _header.nlevels = uint16_t(_levels.size());</div>
<div class="line">    _header.nfaces = uint32_t(_faceinfo.size());</div>
<div class="line"></div>
<div class="line"> <span class="comment">// create new file</span></div>
<div class="line">    FILE* newfp = fopen(_newpath.c_str(), <span class="stringliteral">"wb+"</span>);</div>
<div class="line"> <span class="keywordflow">if</span> (!newfp) {</div>
<div class="line">    setError(fileError(<span class="stringliteral">"Can't write to ptex file: "</span>, _newpath.c_str()));</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// write blank header (to fill in later)</span></div>
<div class="line">    writeBlank(newfp, HeaderSize);</div>
<div class="line">    writeBlank(newfp, ExtHeaderSize);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// write compressed face info block</span></div>
<div class="line">    _header.faceinfosize = writeZipBlock(newfp, &amp;_faceinfo[0],</div>
<div class="line"> <span class="keyword">sizeof</span>(FaceInfo)*_header.nfaces);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// write compressed const data block</span></div>
<div class="line">    _header.constdatasize = writeZipBlock(newfp, &amp;_constdata[0], <span class="keywordtype">int</span>(_constdata.size()));</div>
<div class="line"></div>
<div class="line"> <span class="comment">// write blank level info block (to fill in later)</span></div>
<div class="line">    FilePos levelInfoPos = ftello(newfp);</div>
<div class="line">    writeBlank(newfp, LevelInfoSize * _header.nlevels);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// write level data blocks (and record level info)</span></div>
<div class="line">    std::vector&lt;LevelInfo&gt; levelinfo(_header.nlevels);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> li = 0; li &lt; _header.nlevels; li++)</div>
<div class="line">    {</div>
<div class="line">    LevelInfo&amp; info = levelinfo[li];</div>
<div class="line">    LevelRec&amp; <a class="code" href="./_g_lee_8h.html#abc60a79088789bd61297bf5f9ff500d1">level</a> = _levels[li];</div>
<div class="line"> <span class="keywordtype">int</span> nfaces = <a name="a12"></a><a class="code" href="./_g_lee_8h.html#aa813ad7a4a00cda401ffd0c336154620">int</a>(level.fdh.size());</div>
<div class="line">    info.nfaces = nfaces;</div>
<div class="line"> <span class="comment">// output compressed level data header</span></div>
<div class="line">    info.levelheadersize = writeZipBlock(newfp, &amp;level.fdh[0],</div>
<div class="line"> <span class="keyword">sizeof</span>(FaceDataHeader)*nfaces);</div>
<div class="line">    info.leveldatasize = info.levelheadersize;</div>
<div class="line"> <span class="comment">// copy level data from tmp file</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> fi = 0; fi &lt; nfaces; fi++)</div>
<div class="line">        info.leveldatasize += copyBlock(newfp, _tmpfp, level.pos[fi],</div>
<div class="line">                        level.fdh[fi].blocksize());</div>
<div class="line">    _header.leveldatasize += info.leveldatasize;</div>
<div class="line">    }</div>
<div class="line">    rewind(_tmpfp);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// write meta data (if any)</span></div>
<div class="line"> <span class="keywordflow">if</span> (!_metadata.empty())</div>
<div class="line">    writeMetaData(newfp);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// update extheader for edit data position</span></div>
<div class="line">    _extheader.editdatapos = ftello(newfp);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// rewrite level info block</span></div>
<div class="line">    fseeko(newfp, levelInfoPos, SEEK_SET);</div>
<div class="line">    _header.levelinfosize = writeBlock(newfp, &amp;levelinfo[0], LevelInfoSize*_header.nlevels);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// rewrite header</span></div>
<div class="line">    fseeko(newfp, 0, SEEK_SET);</div>
<div class="line">    writeBlock(newfp, &amp;_header, HeaderSize);</div>
<div class="line">    writeBlock(newfp, &amp;_extheader, ExtHeaderSize);</div>
<div class="line">    fclose(newfp);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexMainWriter::flagConstantNeighorhoods()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// for each constant face</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> faceid = 0, n = <span class="keywordtype">int</span>(_faceinfo.size()); faceid &lt; <a name="a13"></a><a class="code" href="./_g_lee_8h.html#a830e6eb5d1b77f7226a78592ba9d2613">n</a>; faceid++) {</div>
<div class="line">    FaceInfo&amp; f = _faceinfo[faceid];</div>
<div class="line"> <span class="keywordflow">if</span> (!f.isConstant()) <span class="keywordflow">continue</span>;</div>
<div class="line">    uint8_t* constdata = &amp;_constdata[faceid*_pixelSize];</div>
<div class="line"></div>
<div class="line"> <span class="comment">// check to see if neighborhood is constant</span></div>
<div class="line"> <span class="keywordtype">bool</span> isConst = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordtype">bool</span> isTriangle = _header.meshtype == mt_triangle;</div>
<div class="line"> <span class="keywordtype">int</span> nedges = isTriangle ? 3 : 4;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> eid = 0; eid &lt; nedges; eid++) {</div>
<div class="line"> <span class="keywordtype">bool</span> prevWasSubface = f.isSubface();</div>
<div class="line"> <span class="keywordtype">int</span> prevFid = faceid;</div>
<div class="line"> <span class="comment">// traverse across edge</span></div>
<div class="line"> <span class="keywordtype">int</span> afid = f.adjface(eid);</div>
<div class="line"> <span class="keywordtype">int</span> aeid = f.adjedge(eid);</div>
<div class="line"> <span class="keywordtype">int</span> count = 0;</div>
<div class="line"> <span class="keyword">const</span> <span class="keywordtype">int</span> maxcount = 10; <span class="comment">// max valence (as safety valve)</span></div>
<div class="line"> <span class="keywordflow">while</span> (afid != faceid) {</div>
<div class="line"> <span class="comment">// if we hit a boundary, assume non-const (not worth</span></div>
<div class="line"> <span class="comment">// the trouble to redo traversal from CCW direction;</span></div>
<div class="line"> <span class="comment">// also, boundary might want to be "black")</span></div>
<div class="line"> <span class="comment">// assume const if we hit max valence too</span></div>
<div class="line"> <span class="keywordflow">if</span> (afid &lt; 0 || ++count == maxcount)</div>
<div class="line">        { isConst = <span class="keyword">false</span>; <span class="keywordflow">break</span>; }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// check if neighor is constant, and has the same value as face</span></div>
<div class="line">        FaceInfo&amp; af = _faceinfo[afid];</div>
<div class="line"> <span class="keywordflow">if</span> (!af.isConstant() ||</div>
<div class="line">            0 != memcmp(constdata, &amp;_constdata[afid*_pixelSize], _pixelSize))</div>
<div class="line">        { isConst = <span class="keyword">false</span>; <span class="keywordflow">break</span>; }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// traverse around vertex in CW direction</span></div>
<div class="line"> <span class="comment">// handle T junction between subfaces and main face</span></div>
<div class="line"> <span class="keywordtype">bool</span> isSubface = af.isSubface();</div>
<div class="line"> <span class="keywordtype">bool</span> isT = !isTriangle &amp;&amp; prevWasSubface &amp;&amp; !isSubface &amp;&amp; af.adjface(aeid) == prevFid;</div>
<div class="line"> <a name="a14"></a><a class="code" href="./namespacestd.html#a48315615ae44e23b2308833bd7116ba5">std::swap</a>(prevFid, afid);</div>
<div class="line">        prevWasSubface = isSubface;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (isT) {</div>
<div class="line"> <span class="comment">// traverse to secondary subface across T junction</span></div>
<div class="line">            FaceInfo&amp; pf = _faceinfo[afid];</div>
<div class="line"> <span class="keywordtype">int</span> peid = af.adjedge(aeid);</div>
<div class="line">            peid = (peid + 3) % 4;</div>
<div class="line">            afid = pf.adjface(peid);</div>
<div class="line">            aeid = pf.adjedge(peid);</div>
<div class="line">            aeid = (aeid + 3) % 4;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// traverse around vertex</span></div>
<div class="line">            aeid = (aeid + 1) % nedges;</div>
<div class="line">            afid = af.adjface(aeid);</div>
<div class="line">            aeid = af.adjedge(aeid);</div>
<div class="line">        }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">if</span> (!isConst) <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (isConst) f.flags |= FaceInfo::flag_nbconstant;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexMainWriter::generateReductions()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// first generate "rfaceids", reduction faceids,</span></div>
<div class="line"> <span class="comment">// which are faceids reordered by decreasing smaller dimension</span></div>
<div class="line"> <span class="keywordtype">int</span> nfaces = _header.nfaces;</div>
<div class="line">    _rfaceids.resize(nfaces);</div>
<div class="line">    _faceids_r.resize(nfaces);</div>
<div class="line">    PtexUtils::genRfaceids(&amp;_faceinfo[0], nfaces, &amp;_rfaceids[0], &amp;_faceids_r[0]);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// determine how many faces in each level, and resize _levels</span></div>
<div class="line"> <span class="comment">// traverse in reverse rfaceid order to find number of faces</span></div>
<div class="line"> <span class="comment">// larger than cutoff size of each level</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> rfaceid = nfaces-1, cutoffres = MinReductionLog2; rfaceid &gt;= 0; rfaceid--) {</div>
<div class="line"> <span class="keywordtype">int</span> faceid = _faceids_r[rfaceid];</div>
<div class="line">    FaceInfo&amp; <a class="code" href="./_g_lee_8h.html#a676ca580c460c0154eb58200433d2a9e">face</a> = _faceinfo[faceid];</div>
<div class="line">    Res res = face.res;</div>
<div class="line"> <span class="keywordtype">int</span> min = face.isConstant() ? 1 : PtexUtils::min(res.ulog2, res.vlog2);</div>
<div class="line"> <span class="keywordflow">while</span> (min &gt; cutoffres) {</div>
<div class="line"> <span class="comment">// i == last face for current level</span></div>
<div class="line"> <span class="keywordtype">int</span> size = rfaceid+1;</div>
<div class="line">        _levels.push_back(LevelRec());</div>
<div class="line">        LevelRec&amp; level = _levels.back();</div>
<div class="line">        level.pos.resize(size);</div>
<div class="line">        level.fdh.resize(size);</div>
<div class="line">        cutoffres++;</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// generate and cache reductions (including const data)</span></div>
<div class="line"> <span class="comment">// first, find largest face and allocate tmp buffer</span></div>
<div class="line"> <span class="keywordtype">int</span> buffsize = 0;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nfaces; i++)</div>
<div class="line">    buffsize = <a name="a15"></a><a class="code" href="./_g_lee_8h.html#a8fa4ae5e2b2ef3e57a2bde9530581904">PtexUtils::max</a>(buffsize, _faceinfo[i].res.size());</div>
<div class="line">    buffsize *= _pixelSize;</div>
<div class="line"> <span class="keywordtype">char</span>* buff = (<span class="keywordtype">char</span>*) malloc(buffsize);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> nlevels = <a class="code" href="./_g_lee_8h.html#aa813ad7a4a00cda401ffd0c336154620">int</a>(_levels.size());</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; nlevels; i++) {</div>
<div class="line">    LevelRec&amp; level = _levels[i];</div>
<div class="line"> <span class="keywordtype">int</span> nextsize = (i+1 &lt; nlevels)? <span class="keywordtype">int</span>(_levels[i+1].fdh.size()) : 0;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> rfaceid = 0, size = <span class="keywordtype">int</span>(level.fdh.size()); rfaceid &lt; <a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>; rfaceid++) {</div>
<div class="line"> <span class="comment">// output current reduction for face (previously generated)</span></div>
<div class="line"> <span class="keywordtype">int</span> faceid = _faceids_r[rfaceid];</div>
<div class="line">        Res res = _faceinfo[faceid].res;</div>
<div class="line">        res.ulog2 -= i; res.vlog2 -= i;</div>
<div class="line"> <span class="keywordtype">int</span> stride = res.u() * _pixelSize;</div>
<div class="line"> <span class="keywordtype">int</span> blocksize = res.size() * _pixelSize;</div>
<div class="line">        fseeko(_tmpfp, _rpos[faceid], SEEK_SET);</div>
<div class="line">        readBlock(_tmpfp, buff, blocksize);</div>
<div class="line">        fseeko(_tmpfp, 0, SEEK_END);</div>
<div class="line">        level.pos[rfaceid] = ftello(_tmpfp);</div>
<div class="line">        writeFaceData(_tmpfp, buff, stride, res, level.fdh[rfaceid]);</div>
<div class="line"> <span class="keywordflow">if</span> (!_ok) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// write a new reduction if needed for next level</span></div>
<div class="line"> <span class="keywordflow">if</span> (rfaceid &lt; nextsize) {</div>
<div class="line">        fseeko(_tmpfp, _rpos[faceid], SEEK_SET);</div>
<div class="line">        writeReduction(_tmpfp, buff, stride, res);</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// the last reduction for each face is its constant value</span></div>
<div class="line">        storeConstValue(faceid, buff, stride, res);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line">    fseeko(_tmpfp, 0, SEEK_END);</div>
<div class="line">    free(buff);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexMainWriter::writeMetaData(FILE* fp)</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;MetaEntry*&gt; lmdEntries; <span class="comment">// large meta data items</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// write small meta data items in a single zip block</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0, n = _metadata.size(); i &lt; <a class="code" href="./_g_lee_8h.html#a830e6eb5d1b77f7226a78592ba9d2613">n</a>; i++) {</div>
<div class="line">    MetaEntry&amp; e = _metadata[i];</div>
<div class="line"> <span class="keywordflow">if</span> (<span class="keywordtype">int</span>(e.data.size()) &gt; MetaDataThreshold) {</div>
<div class="line"> <span class="comment">// skip large items, but record for later</span></div>
<div class="line">        lmdEntries.push_back(&amp;e);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// add small item to zip block</span></div>
<div class="line">        _header.metadatamemsize += writeMetaDataBlock(fp, e);</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (_header.metadatamemsize) {</div>
<div class="line"> <span class="comment">// finish zip block</span></div>
<div class="line">    _header.metadatazipsize = writeZipBlock(fp, 0, 0, <span class="comment">/*finish*/</span> <span class="keyword">true</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// write compatibility barrier</span></div>
<div class="line">    writeBlank(fp, <span class="keyword">sizeof</span>(uint64_t));</div>
<div class="line"></div>
<div class="line"> <span class="comment">// write large items as separate blocks</span></div>
<div class="line"> <span class="keywordtype">int</span> nLmd = lmdEntries.size();</div>
<div class="line"> <span class="keywordflow">if</span> (nLmd &gt; 0) {</div>
<div class="line"> <span class="comment">// write data records to tmp file and accumulate zip sizes for lmd header</span></div>
<div class="line">    std::vector&lt;FilePos&gt; lmdoffset(nLmd);</div>
<div class="line">    std::vector&lt;uint32_t&gt; lmdzipsize(nLmd);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nLmd; i++) {</div>
<div class="line">        MetaEntry* e= lmdEntries[i];</div>
<div class="line">        lmdoffset[i] = ftello(_tmpfp);</div>
<div class="line">        lmdzipsize[i] = writeZipBlock(_tmpfp, &amp;e-&gt;data[0], e-&gt;data.size());</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// write lmd header records as single zip block</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nLmd; i++) {</div>
<div class="line">        MetaEntry* e = lmdEntries[i];</div>
<div class="line">        uint8_t keysize = uint8_t(e-&gt;key.size()+1);</div>
<div class="line">        uint8_t datatype = e-&gt;datatype;</div>
<div class="line">        uint32_t datasize = e-&gt;data.size();</div>
<div class="line">        uint32_t zipsize = lmdzipsize[i];</div>
<div class="line"></div>
<div class="line">        writeZipBlock(fp, &amp;keysize, <span class="keyword">sizeof</span>(keysize), <span class="keyword">false</span>);</div>
<div class="line">        writeZipBlock(fp, e-&gt;key.c_str(), keysize, <span class="keyword">false</span>);</div>
<div class="line">        writeZipBlock(fp, &amp;datatype, <span class="keyword">sizeof</span>(datatype), <span class="keyword">false</span>);</div>
<div class="line">        writeZipBlock(fp, &amp;datasize, <span class="keyword">sizeof</span>(datasize), <span class="keyword">false</span>);</div>
<div class="line">        writeZipBlock(fp, &amp;zipsize, <span class="keyword">sizeof</span>(zipsize), <span class="keyword">false</span>);</div>
<div class="line">        _extheader.lmdheadermemsize +=</div>
<div class="line"> <span class="keyword">sizeof</span>(keysize) + keysize + <span class="keyword">sizeof</span>(datatype) + <span class="keyword">sizeof</span>(datasize) + <span class="keyword">sizeof</span>(zipsize);</div>
<div class="line">    }</div>
<div class="line">    _extheader.lmdheaderzipsize = writeZipBlock(fp, 0, 0, <span class="comment">/*finish*/</span> <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// copy data records</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nLmd; i++) {</div>
<div class="line">        _extheader.lmddatasize +=</div>
<div class="line">        copyBlock(fp, _tmpfp, lmdoffset[i], lmdzipsize[i]);</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">PtexIncrWriter::PtexIncrWriter(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, FILE* fp,</div>
<div class="line">                   Ptex::MeshType mt, Ptex::DataType dt,</div>
<div class="line"> <span class="keywordtype">int</span> nchannels, <span class="keywordtype">int</span> alphachan, <span class="keywordtype">int</span> nfaces)</div>
<div class="line">    : PtexWriterBase(path, mt, dt, nchannels, alphachan, nfaces,</div>
<div class="line"> <span class="comment">/* compress */</span> false),</div>
<div class="line">      _fp(fp)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// note: incremental saves are not compressed (see compress flag above)</span></div>
<div class="line"> <span class="comment">// to improve save time in the case where in incremental save is followed by</span></div>
<div class="line"> <span class="comment">// a full save (which ultimately it always should be).  With a compressed</span></div>
<div class="line"> <span class="comment">// incremental save, the data would be compressed twice and decompressed once</span></div>
<div class="line"> <span class="comment">// on every save vs. just compressing once.</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// make sure existing header matches</span></div>
<div class="line"> <span class="keywordflow">if</span> (!fread(&amp;_header, PtexIO::HeaderSize, 1, fp) || _header.magic != Magic) {</div>
<div class="line">    std::stringstream str;</div>
<div class="line">    str &lt;&lt; <span class="stringliteral">"Not a ptex file: "</span> &lt;&lt; path;</div>
<div class="line">    setError(str.str());</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">bool</span> headerMatch = (mt == _header.meshtype &amp;&amp;</div>
<div class="line">            dt == _header.datatype &amp;&amp;</div>
<div class="line">            nchannels == _header.nchannels &amp;&amp;</div>
<div class="line">            alphachan == <a class="code" href="./_g_lee_8h.html#aa813ad7a4a00cda401ffd0c336154620">int</a>(_header.alphachan) &amp;&amp;</div>
<div class="line">            nfaces == <a class="code" href="./_g_lee_8h.html#aa813ad7a4a00cda401ffd0c336154620">int</a>(_header.nfaces));</div>
<div class="line"> <span class="keywordflow">if</span> (!headerMatch) {</div>
<div class="line">    std::stringstream str;</div>
<div class="line">    str &lt;&lt; <span class="stringliteral">"PtexWriter::edit error: header doesn't match existing file, "</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">"conversions not currently supported"</span>;</div>
<div class="line">    setError(str.str());</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// read extended header</span></div>
<div class="line">    memset(&amp;_extheader, 0, <span class="keyword">sizeof</span>(_extheader));</div>
<div class="line"> <span class="keywordflow">if</span> (!fread(&amp;_extheader, PtexUtils::min(uint32_t(ExtHeaderSize), _header.extheadersize), 1, fp)) {</div>
<div class="line">    std::stringstream str;</div>
<div class="line">    str &lt;&lt; <span class="stringliteral">"Error reading extended header: "</span> &lt;&lt; path;</div>
<div class="line">    setError(str.str());</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// seek to end of file to append</span></div>
<div class="line">    fseeko(_fp, 0, SEEK_END);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">PtexIncrWriter::~PtexIncrWriter()</div>
<div class="line">{</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> PtexIncrWriter::writeFace(<span class="keywordtype">int</span> faceid, <span class="keyword">const</span> FaceInfo&amp; f, <span class="keyword">const</span> <span class="keywordtype">void</span>* data, <span class="keywordtype">int</span> stride)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (stride == 0) stride = f.res.u()*_pixelSize;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// handle constant case</span></div>
<div class="line"> <span class="keywordflow">if</span> (PtexUtils::isConstant(data, stride, f.res.u(), f.res.v(), _pixelSize))</div>
<div class="line"> <span class="keywordflow">return</span> writeConstantFace(faceid, f, data);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// init headers</span></div>
<div class="line">    uint8_t edittype = et_editfacedata;</div>
<div class="line">    uint32_t editsize;</div>
<div class="line">    EditFaceDataHeader efdh;</div>
<div class="line">    efdh.faceid = faceid;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// check and store face info</span></div>
<div class="line"> <span class="keywordflow">if</span> (!storeFaceInfo(faceid, efdh.faceinfo, f))</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// record position and skip headers</span></div>
<div class="line">    FilePos pos = ftello(_fp);</div>
<div class="line">    writeBlank(_fp, <span class="keyword">sizeof</span>(edittype) + <span class="keyword">sizeof</span>(editsize) + <span class="keyword">sizeof</span>(efdh));</div>
<div class="line"></div>
<div class="line"> <span class="comment">// must compute constant (average) val first</span></div>
<div class="line">    uint8_t* constval = (uint8_t*) malloc(_pixelSize);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (_header.hasAlpha()) {</div>
<div class="line"> <span class="comment">// must premult alpha before averaging</span></div>
<div class="line"> <span class="comment">// first copy to temp buffer</span></div>
<div class="line"> <span class="keywordtype">int</span> rowlen = f.res.u() * _pixelSize, nrows = f.res.v();</div>
<div class="line">    uint8_t* temp = (uint8_t*) malloc(rowlen * nrows);</div>
<div class="line">    PtexUtils::copy(data, stride, temp, rowlen, nrows, rowlen);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// multiply alpha</span></div>
<div class="line">    PtexUtils::multalpha(temp, f.res.size(), _header.datatype, _header.nchannels,</div>
<div class="line">                 _header.alphachan);</div>
<div class="line"> <span class="comment">// average</span></div>
<div class="line">    PtexUtils::average(temp, rowlen, f.res.u(), f.res.v(), constval,</div>
<div class="line">               _header.datatype, _header.nchannels);</div>
<div class="line"> <span class="comment">// unmult alpha</span></div>
<div class="line">    PtexUtils::divalpha(constval, 1, _header.datatype, _header.nchannels,</div>
<div class="line">                _header.alphachan);</div>
<div class="line">    free(temp);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// average</span></div>
<div class="line">    PtexUtils::average(data, stride, f.res.u(), f.res.v(), constval,</div>
<div class="line">               _header.datatype, _header.nchannels);</div>
<div class="line">    }</div>
<div class="line"> <span class="comment">// write const val</span></div>
<div class="line">    writeBlock(_fp, constval, _pixelSize);</div>
<div class="line">    free(constval);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// write face data</span></div>
<div class="line">    writeFaceData(_fp, data, stride, f.res, efdh.fdh);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// update editsize in header</span></div>
<div class="line">    editsize = <span class="keyword">sizeof</span>(efdh) + _pixelSize + efdh.fdh.blocksize();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// rewind and write headers</span></div>
<div class="line">    fseeko(_fp, pos, SEEK_SET);</div>
<div class="line">    writeBlock(_fp, &amp;edittype, <span class="keyword">sizeof</span>(edittype));</div>
<div class="line">    writeBlock(_fp, &amp;editsize, <span class="keyword">sizeof</span>(editsize));</div>
<div class="line">    writeBlock(_fp, &amp;efdh, <span class="keyword">sizeof</span>(efdh));</div>
<div class="line">    fseeko(_fp, 0, SEEK_END);</div>
<div class="line"> <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> PtexIncrWriter::writeConstantFace(<span class="keywordtype">int</span> faceid, <span class="keyword">const</span> FaceInfo&amp; f, <span class="keyword">const</span> <span class="keywordtype">void</span>* data)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// init headers</span></div>
<div class="line">    uint8_t edittype = et_editfacedata;</div>
<div class="line">    uint32_t editsize;</div>
<div class="line">    EditFaceDataHeader efdh;</div>
<div class="line">    efdh.faceid = faceid;</div>
<div class="line">    efdh.fdh.set(0, enc_constant);</div>
<div class="line">    editsize = <span class="keyword">sizeof</span>(efdh) + _pixelSize;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// check and store face info</span></div>
<div class="line"> <span class="keywordflow">if</span> (!storeFaceInfo(faceid, efdh.faceinfo, f, FaceInfo::flag_constant))</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// write headers</span></div>
<div class="line">    writeBlock(_fp, &amp;edittype, <span class="keyword">sizeof</span>(edittype));</div>
<div class="line">    writeBlock(_fp, &amp;editsize, <span class="keyword">sizeof</span>(editsize));</div>
<div class="line">    writeBlock(_fp, &amp;efdh, <span class="keyword">sizeof</span>(efdh));</div>
<div class="line"> <span class="comment">// write data</span></div>
<div class="line">    writeBlock(_fp, data, _pixelSize);</div>
<div class="line"> <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexIncrWriter::writeMetaDataEdit()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// init headers</span></div>
<div class="line">    uint8_t edittype = et_editmetadata;</div>
<div class="line">    uint32_t editsize;</div>
<div class="line">    EditMetaDataHeader emdh;</div>
<div class="line">    emdh.metadatazipsize = 0;</div>
<div class="line">    emdh.metadatamemsize = 0;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// record position and skip headers</span></div>
<div class="line">    FilePos pos = ftello(_fp);</div>
<div class="line">    writeBlank(_fp, <span class="keyword">sizeof</span>(edittype) + <span class="keyword">sizeof</span>(editsize) + <span class="keyword">sizeof</span>(emdh));</div>
<div class="line"></div>
<div class="line"> <span class="comment">// write meta data</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0, n = _metadata.size(); i &lt; <a class="code" href="./_g_lee_8h.html#a830e6eb5d1b77f7226a78592ba9d2613">n</a>; i++) {</div>
<div class="line">    MetaEntry&amp; e = _metadata[i];</div>
<div class="line">    emdh.metadatamemsize += writeMetaDataBlock(_fp, e);</div>
<div class="line">    }</div>
<div class="line"> <span class="comment">// finish zip block</span></div>
<div class="line">    emdh.metadatazipsize = writeZipBlock(_fp, 0, 0, <span class="comment">/*finish*/</span> <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// update headers</span></div>
<div class="line">    editsize = <span class="keyword">sizeof</span>(emdh) + emdh.metadatazipsize;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// rewind and write headers</span></div>
<div class="line">    fseeko(_fp, pos, SEEK_SET);</div>
<div class="line">    writeBlock(_fp, &amp;edittype, <span class="keyword">sizeof</span>(edittype));</div>
<div class="line">    writeBlock(_fp, &amp;editsize, <span class="keyword">sizeof</span>(editsize));</div>
<div class="line">    writeBlock(_fp, &amp;emdh, <span class="keyword">sizeof</span>(emdh));</div>
<div class="line">    fseeko(_fp, 0, SEEK_END);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> PtexIncrWriter::close(Ptex::String&amp; error)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// closing base writer will write all pending data via finish() method</span></div>
<div class="line"> <span class="keywordtype">bool</span> result = PtexWriterBase::close(error);</div>
<div class="line"> <span class="keywordflow">if</span> (_fp) {</div>
<div class="line">    fclose(_fp);</div>
<div class="line">    _fp = 0;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexIncrWriter::finish()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// write meta data edit block (if any)</span></div>
<div class="line"> <span class="keywordflow">if</span> (!_metadata.empty()) writeMetaDataEdit();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// rewrite extheader for updated editdatasize</span></div>
<div class="line"> <span class="keywordflow">if</span> (_extheader.editdatapos) {</div>
<div class="line">    _extheader.editdatasize = uint64_t(ftello(_fp)) - _extheader.editdatapos;</div>
<div class="line">    fseeko(_fp, HeaderSize, SEEK_SET);</div>
<div class="line">    fwrite(&amp;_extheader, PtexUtils::min(uint32_t(ExtHeaderSize), _header.extheadersize), 1, _fp);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div class="footer-block"><a class="comments-anchor" href="../html/ac.cmtdialog.htm" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
</div></body>
</html>
