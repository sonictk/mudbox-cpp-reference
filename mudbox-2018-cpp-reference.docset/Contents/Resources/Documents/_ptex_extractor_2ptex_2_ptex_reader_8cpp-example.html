<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
<head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><meta content="MOBPRO" name="product"/><meta content="2018" name="release"/><meta content="GeneralUser" name="book"/><meta content="2017-09-08" name="created"/><meta content="GUID-02FA7DD3-6C7A-4C6A-B7BC-824765AE1CB2" name="topicid"/><meta content="concept" name="topic-type"/>
<title>PtexExtractor/ptex/PtexReader.cpp</title>
</head>
<body height="100%"><div class="body_content" id="body-content"><link href="../style/navtree.css" rel="stylesheet" type="text/css"/><link href="../style/doxygen.css" rel="stylesheet" type="text/css"/><link href="../style/tabs.css" rel="stylesheet" type="text/css"/><link href="../style/adsk.cpm.css" rel="stylesheet" type="text/css"/><script language="javascript">var index = 'index.html';</script><script>$(document).ready(function() { yepnope.injectJs("./scripts/ac_common.js"); });</script><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('_ptex_extractor_2ptex_2_ptex_reader_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type="text/javascript">$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
<div class="Dark" id="MicrosoftTranslatorWidget" style="float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden"></div>
<div>
<div class="head">
<h1>PtexExtractor/ptex/PtexReader.cpp</h1>
</div>
<div id="top"><!-- Generated by Doxygen 1.8.10 -->
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="./index.html"><span>MainÂ Page</span></a></li>
<li><a href="./pages.html"><span>Topics</span></a></li>
<li><a href="./modules.html"><span>Modules</span></a></li>
<li><a href="./namespaces.html"><span>Namespaces</span></a></li>
<li><a href="./annotated.html"><span>Classes</span></a></li>
<li><a href="./files.html"><span>Files</span></a></li>
<li><a href="./examples.html"><span>Examples</span></a></li>
</ul>
</div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<div id="doc-content">
<div class="header">
<div class="headertitle">
<div class="title">PtexExtractor/ptex/PtexReader.cpp</div> </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">/* </span></div>
<div class="line"><span class="comment">PTEX SOFTWARE</span></div>
<div class="line"><span class="comment">Copyright 2009 Disney Enterprises, Inc.  All rights reserved</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">Redistribution and use in source and binary forms, with or without</span></div>
<div class="line"><span class="comment">modification, are permitted provided that the following conditions are</span></div>
<div class="line"><span class="comment">met:</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  * Redistributions of source code must retain the above copyright</span></div>
<div class="line"><span class="comment">    notice, this list of conditions and the following disclaimer.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  * Redistributions in binary form must reproduce the above copyright</span></div>
<div class="line"><span class="comment">    notice, this list of conditions and the following disclaimer in</span></div>
<div class="line"><span class="comment">    the documentation and/or other materials provided with the</span></div>
<div class="line"><span class="comment">    distribution.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  * The names "Disney", "Walt Disney Pictures", "Walt Disney Animation</span></div>
<div class="line"><span class="comment">    Studios" or the names of its contributors may NOT be used to</span></div>
<div class="line"><span class="comment">    endorse or promote products derived from this software without</span></div>
<div class="line"><span class="comment">    specific prior written permission from Walt Disney Pictures.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">Disclaimer: THIS SOFTWARE IS PROVIDED BY WALT DISNEY PICTURES AND</span></div>
<div class="line"><span class="comment">CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,</span></div>
<div class="line"><span class="comment">BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS</span></div>
<div class="line"><span class="comment">FOR A PARTICULAR PURPOSE, NONINFRINGEMENT AND TITLE ARE DISCLAIMED.</span></div>
<div class="line"><span class="comment">IN NO EVENT SHALL WALT DISNEY PICTURES, THE COPYRIGHT HOLDER OR</span></div>
<div class="line"><span class="comment">CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span></div>
<div class="line"><span class="comment">EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,</span></div>
<div class="line"><span class="comment">PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span></div>
<div class="line"><span class="comment">PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND BASED ON ANY</span></div>
<div class="line"><span class="comment">THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span></div>
<div class="line"><span class="comment">(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span></div>
<div class="line"><span class="comment">OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include "PtexPlatform.h"</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;errno.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include "Ptexture.h"</span></div>
<div class="line"><span class="preprocessor">#include "PtexUtils.h"</span></div>
<div class="line"><span class="preprocessor">#include "PtexReader.h"</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>{</div>
<div class="line"> <span class="keyword">class </span>DefaultInputHandler : <span class="keyword">public</span> PtexInputHandler</div>
<div class="line">    {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line"> <span class="keyword">virtual</span> Handle open(<span class="keyword">const</span> <span class="keywordtype">char</span>* path) { <span class="keywordflow">return</span> (Handle) fopen(path, <span class="stringliteral">"rb"</span>); }</div>
<div class="line"> <span class="keyword">virtual</span> <span class="keywordtype">void</span> seek(Handle handle, <a name="a0"></a><a class="code" href="./_g_lee_8h.html#a887307629fdf8e2a5f2970881019075b">int64_t</a> pos) { fseeko((FILE*)handle, pos, SEEK_SET); }</div>
<div class="line"> <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> <a name="a1"></a><a class="code" href="./_g_lee_8h.html#ab4ee307df41386f0f6663773cef12b6c">read</a>(<span class="keywordtype">void</span>* <a class="code" href="./_g_lee_8h.html#a3667f558219c90437106b544a3ca00b8">buffer</a>, <span class="keywordtype">size_t</span> <a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>, Handle handle) {</div>
<div class="line"> <span class="keywordflow">return</span> fread(buffer, size, 1, (FILE*)handle) == 1 ? size : 0;</div>
<div class="line">    }</div>
<div class="line"> <span class="keyword">virtual</span> <span class="keywordtype">bool</span> close(Handle handle) { <span class="keywordflow">return</span> fclose((FILE*)handle); }</div>
<div class="line"> <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* lastError() { <span class="keywordflow">return</span> strerror(errno); }</div>
<div class="line">    } defaultInputHandler;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">PtexTexture* PtexTexture::open(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, Ptex::String&amp; error, <span class="keywordtype">bool</span> premultiply)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// create a private cache and use it to open the file</span></div>
<div class="line">    PtexCache* cache = PtexCache::create(1, 1024*1024, premultiply);</div>
<div class="line">    PtexTexture* file = cache-&gt;get(path, error);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// make reader own the cache (so it will delete it later)</span></div>
<div class="line">    PtexReader* reader = <span class="keyword">dynamic_cast&lt;</span>PtexReader*<span class="keyword">&gt;</span> (file);</div>
<div class="line"> <span class="keywordflow">if</span> (reader) reader-&gt;setOwnsCache();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// and purge cache so cache doesn't try to hold reader open</span></div>
<div class="line">    cache-&gt;purgeAll();</div>
<div class="line"> <span class="keywordflow">return</span> file;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> PtexReader::open(<span class="keyword">const</span> <span class="keywordtype">char</span>* path, Ptex::String&amp; error)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!LittleEndian()) {</div>
<div class="line">    error = <span class="stringliteral">"Ptex library doesn't currently support big-endian cpu's"</span>;</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">    _path = path;</div>
<div class="line">    _fp = _io-&gt;open(path);</div>
<div class="line"> <span class="keywordflow">if</span> (!_fp) {</div>
<div class="line"> <a name="a2"></a><a class="code" href="./_g_lee_8h.html#ae9ea2d206f76ea82db7a2ea002fdef2f">std::string</a> errstr = <span class="stringliteral">"Can't open ptex file: "</span>;</div>
<div class="line">    errstr += path; errstr += <span class="stringliteral">"\n"</span>; errstr += _io-&gt;lastError();</div>
<div class="line">    error = errstr.c_str();</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">    readBlock(&amp;_header, HeaderSize);</div>
<div class="line"> <span class="keywordflow">if</span> (_header.magic != Magic) {</div>
<div class="line"> <a class="code" href="./_g_lee_8h.html#ae9ea2d206f76ea82db7a2ea002fdef2f">std::string</a> errstr = <span class="stringliteral">"Not a ptex file: "</span>; errstr += path;</div>
<div class="line">    error = errstr.c_str();</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (_header.version != 1) {</div>
<div class="line"> <span class="keywordtype">char</span> ver[21]; snprintf(ver, 20, <span class="stringliteral">"%d"</span>, _header.version);</div>
<div class="line"> <a class="code" href="./_g_lee_8h.html#ae9ea2d206f76ea82db7a2ea002fdef2f">std::string</a> errstr = <span class="stringliteral">"Unsupported ptex file version ("</span>;</div>
<div class="line">    errstr += ver; errstr += <span class="stringliteral">"): "</span>; errstr += path;</div>
<div class="line">    error = errstr.c_str();</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">    _pixelsize = _header.pixelSize();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// read extended header</span></div>
<div class="line">    memset(&amp;_extheader, 0, <span class="keyword">sizeof</span>(_extheader));</div>
<div class="line">    readBlock(&amp;_extheader, PtexUtils::min(uint32_t(ExtHeaderSize), _header.extheadersize));</div>
<div class="line"></div>
<div class="line"> <span class="comment">// compute offsets of various blocks</span></div>
<div class="line">    FilePos pos = tell();</div>
<div class="line">    _faceinfopos = pos;   pos += _header.faceinfosize;</div>
<div class="line">    _constdatapos = pos;  pos += _header.constdatasize;</div>
<div class="line">    _levelinfopos = pos;  pos += _header.levelinfosize;</div>
<div class="line">    _leveldatapos = pos;  pos += _header.leveldatasize;</div>
<div class="line">    _metadatapos = pos;   pos += _header.metadatazipsize;</div>
<div class="line">                          pos += <span class="keyword">sizeof</span>(uint64_t); <span class="comment">// compatibility barrier</span></div>
<div class="line">    _lmdheaderpos = pos;  pos += _extheader.lmdheaderzipsize;</div>
<div class="line">    _lmddatapos = pos;    pos += _extheader.lmddatasize;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// edit data may not start immediately if additional sections have been added</span></div>
<div class="line"> <span class="comment">// use value from extheader if present (and &gt; pos)</span></div>
<div class="line">    _editdatapos = <a name="a3"></a><a class="code" href="./_g_lee_8h.html#a8fa4ae5e2b2ef3e57a2bde9530581904">PtexUtils::max</a>(FilePos(_extheader.editdatapos), pos);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// read basic file info</span></div>
<div class="line">    readFaceInfo();</div>
<div class="line">    readConstData();</div>
<div class="line">    readLevelInfo();</div>
<div class="line">    readEditData();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// an error occurred while reading the file</span></div>
<div class="line"> <span class="keywordflow">if</span> (!_ok) {</div>
<div class="line">    error = _error.c_str();</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">PtexReader::PtexReader(<span class="keywordtype">void</span>** parent, PtexCacheImpl* cache, <span class="keywordtype">bool</span> premultiply,</div>
<div class="line">               PtexInputHandler* io)</div>
<div class="line">    : PtexCachedFile(parent, cache),</div>
<div class="line">      _io(io ? io : &amp;defaultInputHandler),</div>
<div class="line">      _premultiply(premultiply),</div>
<div class="line">      _ownsCache(false),</div>
<div class="line">      _ok(true),</div>
<div class="line">      _fp(0),</div>
<div class="line">      _pos(0),</div>
<div class="line">      _pixelsize(0),</div>
<div class="line">      _constdata(0),</div>
<div class="line">      _metadata(0),</div>
<div class="line">      _hasEdits(false)</div>
<div class="line">{</div>
<div class="line">    memset(&amp;_header, 0, <span class="keyword">sizeof</span>(_header));</div>
<div class="line">    memset(&amp;_zstream, 0, <span class="keyword">sizeof</span>(_zstream));</div>
<div class="line">    inflateInit(&amp;_zstream);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">PtexReader::~PtexReader()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (_fp) _io-&gt;close(_fp);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// we can free the const data directly since we own it (it doesn't go through the cache)</span></div>
<div class="line"> <span class="keywordflow">if</span> (_constdata) free(_constdata);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// the rest must be orphaned since there may still be references outstanding</span></div>
<div class="line">    orphanList(_levels);</div>
<div class="line"> <span class="keywordflow">for</span> (ReductionMap::iterator i = _reductions.begin(); i != _reductions.end(); i++) {</div>
<div class="line">    FaceData* <a class="code" href="./_g_lee_8h.html#a691492ec0bd6383f91200e49f6ae40ed">f</a> = i-&gt;second;</div>
<div class="line"> <span class="keywordflow">if</span> (f) f-&gt;orphan();</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (_metadata) {</div>
<div class="line">    _metadata-&gt;orphan();</div>
<div class="line">    _metadata = 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    inflateEnd(&amp;_zstream);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (_ownsCache) _cache-&gt;setPendingDelete();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::release()</div>
<div class="line">{</div>
<div class="line">    PtexCacheImpl* cache = _cache;</div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// create local scope for cache lock</span></div>
<div class="line">    AutoLockCache lock(cache-&gt;cachelock);</div>
<div class="line">    unref();</div>
<div class="line">    }</div>
<div class="line"> <span class="comment">// If this reader owns the cache, then releasing it may cause deletion of the</span></div>
<div class="line"> <span class="comment">// reader and thus flag the cache for pending deletion.  Call the cache</span></div>
<div class="line"> <span class="comment">// to handle the pending deletion.</span></div>
<div class="line">    cache-&gt;handlePendingDelete();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> Ptex::FaceInfo&amp; PtexReader::getFaceInfo(<span class="keywordtype">int</span> faceid)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (faceid &gt;= 0 &amp;&amp; uint32_t(faceid) &lt; _faceinfo.size())</div>
<div class="line"> <span class="keywordflow">return</span> _faceinfo[faceid];</div>
<div class="line"></div>
<div class="line"> <span class="keyword">static</span> Ptex::FaceInfo dummy;</div>
<div class="line"> <span class="keywordflow">return</span> dummy;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::readFaceInfo()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (_faceinfo.empty()) {</div>
<div class="line"> <span class="comment">// read compressed face info block</span></div>
<div class="line">    seek(_faceinfopos);</div>
<div class="line"> <span class="keywordtype">int</span> nfaces = _header.nfaces;</div>
<div class="line">    _faceinfo.resize(nfaces);</div>
<div class="line">    readZipBlock(&amp;_faceinfo[0], _header.faceinfosize,</div>
<div class="line"> <span class="keyword">sizeof</span>(FaceInfo)*nfaces);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// generate rfaceids</span></div>
<div class="line">    _rfaceids.resize(nfaces);</div>
<div class="line">    std::vector&lt;uint32_t&gt; faceids_r(nfaces);</div>
<div class="line">    PtexUtils::genRfaceids(&amp;_faceinfo[0], nfaces,</div>
<div class="line">                   &amp;_rfaceids[0], &amp;faceids_r[0]);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// store face res values indexed by rfaceid</span></div>
<div class="line">    _res_r.resize(nfaces);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nfaces; i++)</div>
<div class="line">        _res_r[i] = _faceinfo[faceids_r[i]].<a class="code" href="./_g_lee_8h.html#a1dbb21208b9047cc8031ca9c840d3c2f">res</a>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::readLevelInfo()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (_levelinfo.empty()) {</div>
<div class="line"> <span class="comment">// read level info block</span></div>
<div class="line">    seek(_levelinfopos);</div>
<div class="line">    _levelinfo.resize(_header.nlevels);</div>
<div class="line">    readBlock(&amp;_levelinfo[0], LevelInfoSize*_header.nlevels);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// initialize related data</span></div>
<div class="line">    _levels.resize(_header.nlevels);</div>
<div class="line">    _levelpos.resize(_header.nlevels);</div>
<div class="line">    FilePos pos = _leveldatapos;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; _header.nlevels; i++) {</div>
<div class="line">        _levelpos[i] = pos;</div>
<div class="line">        pos += _levelinfo[i].leveldatasize;</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::readConstData()</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!_constdata) {</div>
<div class="line"> <span class="comment">// read compressed constant data block</span></div>
<div class="line">    seek(_constdatapos);</div>
<div class="line"> <span class="keywordtype">int</span> <a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a> = _pixelsize * _header.nfaces;</div>
<div class="line">    _constdata = (uint8_t*) malloc(size);</div>
<div class="line">    readZipBlock(_constdata, _header.constdatasize, size);</div>
<div class="line"> <span class="keywordflow">if</span> (_premultiply &amp;&amp; _header.hasAlpha())</div>
<div class="line">        PtexUtils::multalpha(_constdata, _header.nfaces, _header.datatype,</div>
<div class="line">                 _header.nchannels, _header.alphachan);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">PtexMetaData* PtexReader::getMetaData()</div>
<div class="line">{</div>
<div class="line">    AutoLockCache locker(_cache-&gt;cachelock);</div>
<div class="line"> <span class="keywordflow">if</span> (_metadata) _metadata-&gt;ref();</div>
<div class="line"> <span class="keywordflow">else</span> readMetaData();</div>
<div class="line"> <span class="keywordflow">return</span> _metadata;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">PtexReader::MetaData::Entry*</div>
<div class="line">PtexReader::MetaData::getEntry(<span class="keyword">const</span> <span class="keywordtype">char</span>* key)</div>
<div class="line">{</div>
<div class="line">    MetaMap::iterator iter = _map.find(key);</div>
<div class="line"> <span class="keywordflow">if</span> (iter == _map.end()) {</div>
<div class="line"> <span class="comment">// not found</span></div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Entry* e = &amp;iter-&gt;second;</div>
<div class="line"> <span class="keywordflow">if</span> (!e-&gt;isLmd) {</div>
<div class="line"> <span class="comment">// normal (small) meta data - just return directly</span></div>
<div class="line"> <span class="keywordflow">return</span> e;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// large meta data - may not be read in yet</span></div>
<div class="line">    AutoLockCache lock(_cache-&gt;cachelock);</div>
<div class="line"> <span class="keywordflow">if</span> (e-&gt;lmdData) {</div>
<div class="line"> <span class="comment">// already in memory, add a ref</span></div>
<div class="line">    e-&gt;lmdData-&gt;ref();</div>
<div class="line">    _lmdRefs.push_back(e-&gt;lmdData);</div>
<div class="line"> <span class="keywordflow">return</span> e;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// not present, must read from file</span></div>
<div class="line"> <span class="comment">// temporarily release cache lock so other threads can proceed</span></div>
<div class="line">    _cache-&gt;cachelock.unlock();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// get read lock and make sure we still need to read</span></div>
<div class="line">    AutoMutex locker(_reader-&gt;readlock);</div>
<div class="line"> <span class="keywordflow">if</span> (e-&gt;lmdData) {</div>
<div class="line"> <span class="comment">// another thread must have read it while we were waiting</span></div>
<div class="line">        _cache-&gt;cachelock.lock();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// make sure it's still there now that we have the lock</span></div>
<div class="line"> <span class="keywordflow">if</span> (e-&gt;lmdData) {</div>
<div class="line">        e-&gt;data = e-&gt;lmdData-&gt;data();</div>
<div class="line">        _lmdRefs.push_back(e-&gt;lmdData);</div>
<div class="line">        e-&gt;lmdData-&gt;ref();</div>
<div class="line"> <span class="keywordflow">return</span> e;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="comment">// go ahead and read, keep local until finished</span></div>
<div class="line">    LargeMetaData*&amp; parent = e-&gt;lmdData;</div>
<div class="line">    LargeMetaData* <span class="keyword">volatile</span> lmdData = <span class="keyword">new</span> LargeMetaData((<span class="keywordtype">void</span>**)&amp;parent, _cache, e-&gt;datasize);</div>
<div class="line">    e-&gt;data = lmdData-&gt;data();</div>
<div class="line">    _reader-&gt;seek(e-&gt;lmdPos);</div>
<div class="line">    _reader-&gt;readZipBlock(e-&gt;data, e-&gt;lmdZipSize, e-&gt;datasize);</div>
<div class="line"> <span class="comment">// reacquire cache lock and update entry</span></div>
<div class="line">    _cache-&gt;cachelock.lock();</div>
<div class="line">    e-&gt;lmdData = lmdData;</div>
<div class="line"> <span class="keywordflow">return</span> e;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::readMetaData()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// temporarily release cache lock so other threads can proceed</span></div>
<div class="line">    _cache-&gt;cachelock.unlock();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// get read lock and make sure we still need to read</span></div>
<div class="line">    AutoMutex locker(readlock);</div>
<div class="line"> <span class="keywordflow">if</span> (_metadata) {</div>
<div class="line"> <span class="comment">// another thread must have read it while we were waiting</span></div>
<div class="line">    _cache-&gt;cachelock.lock();</div>
<div class="line"> <span class="comment">// make sure it's still there now that we have the lock</span></div>
<div class="line"> <span class="keywordflow">if</span> (_metadata) {</div>
<div class="line">        _metadata-&gt;ref();</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    _cache-&gt;cachelock.unlock();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="comment">// compute total size (including edit blocks) for cache tracking</span></div>
<div class="line"> <span class="keywordtype">int</span> totalsize = _header.metadatamemsize;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0, size = _metaedits.size(); i &lt; <a name="a4"></a><a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>; i++)</div>
<div class="line">    totalsize += _metaedits[i].memsize;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// allocate new meta data (keep local until fully initialized)</span></div>
<div class="line"> <a name="a5"></a><a class="code" href="./namespace_phonon.html#a85d1594e87e4c4e5da912ca49a87f8d3">MetaData</a>* <span class="keyword">volatile</span> newmeta = <span class="keyword">new</span> <a class="code" href="./namespace_phonon.html#a85d1594e87e4c4e5da912ca49a87f8d3">MetaData</a>(&amp;_metadata, _cache, totalsize, <span class="keyword">this</span>);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// read primary meta data blocks</span></div>
<div class="line"> <span class="keywordflow">if</span> (_header.metadatamemsize)</div>
<div class="line">    readMetaDataBlock(newmeta, _metadatapos,</div>
<div class="line">              _header.metadatazipsize, _header.metadatamemsize);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// read large meta data headers</span></div>
<div class="line"> <span class="keywordflow">if</span> (_extheader.lmdheadermemsize)</div>
<div class="line">    readLargeMetaDataHeaders(newmeta, _lmdheaderpos,</div>
<div class="line">                 _extheader.lmdheaderzipsize, _extheader.lmdheadermemsize);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// read meta data edits</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0, size = _metaedits.size(); i &lt; <a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>; i++)</div>
<div class="line">    readMetaDataBlock(newmeta, _metaedits[i].pos,</div>
<div class="line">              _metaedits[i].zipsize, _metaedits[i].memsize);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// store meta data</span></div>
<div class="line">    _cache-&gt;cachelock.lock();</div>
<div class="line">    _metadata = newmeta;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// clean up unused data</span></div>
<div class="line">    _cache-&gt;purgeData();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::readMetaDataBlock(<a class="code" href="./namespace_phonon.html#a85d1594e87e4c4e5da912ca49a87f8d3">MetaData</a>* metadata, FilePos pos, <span class="keywordtype">int</span> zipsize, <span class="keywordtype">int</span> memsize)</div>
<div class="line">{</div>
<div class="line">    seek(pos);</div>
<div class="line"> <span class="comment">// read from file</span></div>
<div class="line"> <span class="keywordtype">bool</span> useMalloc = memsize &gt; AllocaMax;</div>
<div class="line"> <span class="keywordtype">char</span>* buff = useMalloc ? (<span class="keywordtype">char</span>*) malloc(memsize) : (char*)alloca(memsize);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (readZipBlock(buff, zipsize, memsize)) {</div>
<div class="line"> <span class="comment">// unpack data entries</span></div>
<div class="line"> <span class="keywordtype">char</span>* ptr = buff;</div>
<div class="line"> <span class="keywordtype">char</span>* <a class="code" href="./_g_lee_8h.html#a432111147038972f06e049e18a837002">end</a> = ptr + memsize;</div>
<div class="line"> <span class="keywordflow">while</span> (ptr &lt; end) {</div>
<div class="line">        uint8_t keysize = *ptr++;</div>
<div class="line"> <span class="keywordtype">char</span>* key = (<span class="keywordtype">char</span>*)ptr; ptr += keysize;</div>
<div class="line">        key[keysize-1] = <span class="charliteral">'\0'</span>;</div>
<div class="line">        uint8_t datatype = *ptr++;</div>
<div class="line">        uint32_t datasize; memcpy(&amp;datasize, ptr, <span class="keyword">sizeof</span>(datasize));</div>
<div class="line">        ptr += <span class="keyword">sizeof</span>(datasize);</div>
<div class="line"> <span class="keywordtype">char</span>* <a class="code" href="./_g_lee_8h.html#a2cc7c8468af76cf855e1755c27945693">data</a> = ptr; ptr += datasize;</div>
<div class="line">        metadata-&gt;addEntry(keysize-1, key, datatype, datasize, data);</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (useMalloc) free(buff);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::readLargeMetaDataHeaders(<a class="code" href="./namespace_phonon.html#a85d1594e87e4c4e5da912ca49a87f8d3">MetaData</a>* metadata, FilePos pos, <span class="keywordtype">int</span> zipsize, <span class="keywordtype">int</span> memsize)</div>
<div class="line">{</div>
<div class="line">    seek(pos);</div>
<div class="line"> <span class="comment">// read from file</span></div>
<div class="line"> <span class="keywordtype">bool</span> useMalloc = memsize &gt; AllocaMax;</div>
<div class="line"> <span class="keywordtype">char</span>* buff = useMalloc ? (<span class="keywordtype">char</span>*) malloc(memsize) : (char*)alloca(memsize);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (readZipBlock(buff, zipsize, memsize)) {</div>
<div class="line">    pos += zipsize;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// unpack data entries</span></div>
<div class="line"> <span class="keywordtype">char</span>* ptr = buff;</div>
<div class="line"> <span class="keywordtype">char</span>* end = ptr + memsize;</div>
<div class="line"> <span class="keywordflow">while</span> (ptr &lt; end) {</div>
<div class="line">        uint8_t keysize = *ptr++;</div>
<div class="line"> <span class="keywordtype">char</span>* key = (<span class="keywordtype">char</span>*)ptr; ptr += keysize;</div>
<div class="line">        uint8_t datatype = *ptr++;</div>
<div class="line">        uint32_t datasize; memcpy(&amp;datasize, ptr, <span class="keyword">sizeof</span>(datasize));</div>
<div class="line">        ptr += <span class="keyword">sizeof</span>(datasize);</div>
<div class="line">        uint32_t zipsize; memcpy(&amp;zipsize, ptr, <span class="keyword">sizeof</span>(zipsize));</div>
<div class="line">        ptr += <span class="keyword">sizeof</span>(zipsize);</div>
<div class="line">        metadata-&gt;addLmdEntry(keysize-1, key, datatype, datasize, pos, zipsize);</div>
<div class="line">        pos += zipsize;</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (useMalloc) free(buff);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::readEditData()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// determine file range to scan for edits</span></div>
<div class="line">    FilePos pos = FilePos(_editdatapos), endpos;</div>
<div class="line"> <span class="keywordflow">if</span> (_extheader.editdatapos &gt; 0) {</div>
<div class="line"> <span class="comment">// newer files record the edit data position and size in the extheader</span></div>
<div class="line"> <span class="comment">// note: position will be non-zero even if size is zero</span></div>
<div class="line">    endpos = FilePos(pos + _extheader.editdatasize);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// must have an older file, just read until EOF</span></div>
<div class="line">    endpos = FilePos((uint64_t)-1);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">while</span> (pos &lt; endpos) {</div>
<div class="line">    seek(pos);</div>
<div class="line"> <span class="comment">// read the edit data header</span></div>
<div class="line">    uint8_t edittype = et_editmetadata;</div>
<div class="line">    uint32_t editsize;</div>
<div class="line"> <span class="keywordflow">if</span> (!readBlock(&amp;edittype, <span class="keyword">sizeof</span>(edittype), <span class="comment">/*reporterror*/</span> <span class="keyword">false</span>)) <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">if</span> (!readBlock(&amp;editsize, <span class="keyword">sizeof</span>(editsize), <span class="comment">/*reporterror*/</span> <span class="keyword">false</span>)) <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">if</span> (!editsize) <span class="keywordflow">break</span>;</div>
<div class="line">    _hasEdits = <span class="keyword">true</span>;</div>
<div class="line">    pos = tell() + editsize;</div>
<div class="line"> <span class="keywordflow">switch</span> (edittype) {</div>
<div class="line"> <span class="keywordflow">case</span> et_editfacedata:   readEditFaceData(); <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> et_editmetadata:   readEditMetaData(); <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::readEditFaceData()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// read header</span></div>
<div class="line">    EditFaceDataHeader efdh;</div>
<div class="line"> <span class="keywordflow">if</span> (!readBlock(&amp;efdh, EditFaceDataHeaderSize)) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// update face info</span></div>
<div class="line"> <span class="keywordtype">int</span> faceid = efdh.faceid;</div>
<div class="line"> <span class="keywordflow">if</span> (faceid &lt; 0 || <span class="keywordtype">size_t</span>(faceid) &gt;= _header.nfaces) <span class="keywordflow">return</span>;</div>
<div class="line">    FaceInfo&amp; f = _faceinfo[faceid];</div>
<div class="line">    f = efdh.faceinfo;</div>
<div class="line">    f.flags |= FaceInfo::flag_hasedits;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// read const value now</span></div>
<div class="line">    uint8_t* constdata = _constdata + _pixelsize * faceid;</div>
<div class="line"> <span class="keywordflow">if</span> (!readBlock(constdata, _pixelsize)) <span class="keywordflow">return</span>;</div>
<div class="line"> <span class="keywordflow">if</span> (_premultiply &amp;&amp; _header.hasAlpha())</div>
<div class="line">    PtexUtils::multalpha(constdata, 1, _header.datatype,</div>
<div class="line">                 _header.nchannels, _header.alphachan);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// update header info for remaining data</span></div>
<div class="line"> <span class="keywordflow">if</span> (!f.isConstant()) {</div>
<div class="line">    _faceedits.push_back(FaceEdit());</div>
<div class="line">    FaceEdit&amp; e = _faceedits.back();</div>
<div class="line">    e.pos = tell();</div>
<div class="line">    e.faceid = faceid;</div>
<div class="line">    e.fdh = efdh.fdh;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::readEditMetaData()</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// read header</span></div>
<div class="line">    EditMetaDataHeader emdh;</div>
<div class="line"> <span class="keywordflow">if</span> (!readBlock(&amp;emdh, EditMetaDataHeaderSize)) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// record header info for later</span></div>
<div class="line">    _metaedits.push_back(MetaEdit());</div>
<div class="line">    MetaEdit&amp; e = _metaedits.back();</div>
<div class="line">    e.pos = tell();</div>
<div class="line">    e.zipsize = emdh.metadatazipsize;</div>
<div class="line">    e.memsize = emdh.metadatamemsize;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> PtexReader::readBlock(<span class="keywordtype">void</span>* <a class="code" href="./_g_lee_8h.html#a2cc7c8468af76cf855e1755c27945693">data</a>, <span class="keywordtype">int</span> size, <span class="keywordtype">bool</span> reporterror)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">int</span> result = _io-&gt;read(data, size, _fp);</div>
<div class="line"> <span class="keywordflow">if</span> (result == size) {</div>
<div class="line">    _pos += <a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>;</div>
<div class="line">    STATS_INC(nblocksRead);</div>
<div class="line">    STATS_ADD(nbytesRead, size);</div>
<div class="line"> <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (reporterror)</div>
<div class="line">    setError(<span class="stringliteral">"PtexReader error: read failed (EOF)"</span>);</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> PtexReader::readZipBlock(<span class="keywordtype">void</span>* data, <span class="keywordtype">int</span> zipsize, <span class="keywordtype">int</span> unzipsize)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">void</span>* buff = alloca(BlockSize);</div>
<div class="line">    _zstream.next_out = (Bytef*) data;</div>
<div class="line">    _zstream.avail_out = unzipsize;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">while</span> (1) {</div>
<div class="line"> <span class="keywordtype">int</span> size = (zipsize &lt; BlockSize) ? zipsize : BlockSize;</div>
<div class="line">    zipsize -= <a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>;</div>
<div class="line"> <span class="keywordflow">if</span> (!readBlock(buff, size)) <span class="keywordflow">break</span>;</div>
<div class="line">    _zstream.next_in = (Bytef*) buff;</div>
<div class="line">    _zstream.avail_in = <a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>;</div>
<div class="line"> <span class="keywordtype">int</span> zresult = inflate(&amp;_zstream, zipsize ? Z_NO_FLUSH : Z_FINISH);</div>
<div class="line"> <span class="keywordflow">if</span> (zresult == Z_STREAM_END) <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">if</span> (zresult != Z_OK) {</div>
<div class="line">        setError(<span class="stringliteral">"PtexReader error: unzip failed, file corrupt"</span>);</div>
<div class="line">        inflateReset(&amp;_zstream);</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> total = _zstream.total_out;</div>
<div class="line">    inflateReset(&amp;_zstream);</div>
<div class="line"> <span class="keywordflow">return</span> total == unzipsize;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::readLevel(<span class="keywordtype">int</span> levelid, Level*&amp; <a class="code" href="./_g_lee_8h.html#abc60a79088789bd61297bf5f9ff500d1">level</a>)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// temporarily release cache lock so other threads can proceed</span></div>
<div class="line">    _cache-&gt;cachelock.unlock();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// get read lock and make sure we still need to read</span></div>
<div class="line">    AutoMutex locker(readlock);</div>
<div class="line"> <span class="keywordflow">if</span> (level) {</div>
<div class="line"> <span class="comment">// another thread must have read it while we were waiting</span></div>
<div class="line">    _cache-&gt;cachelock.lock();</div>
<div class="line"> <span class="comment">// make sure it's still there now that we have the lock</span></div>
<div class="line"> <span class="keywordflow">if</span> (level) {</div>
<div class="line">        level-&gt;ref();</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    _cache-&gt;cachelock.unlock();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// go ahead and read the level</span></div>
<div class="line">    LevelInfo&amp; l = _levelinfo[levelid];</div>
<div class="line"></div>
<div class="line"> <span class="comment">// keep new level local until finished</span></div>
<div class="line">    Level* <span class="keyword">volatile</span> newlevel = <span class="keyword">new</span> Level((<span class="keywordtype">void</span>**)&amp;level, _cache, l.nfaces);</div>
<div class="line">    seek(_levelpos[levelid]);</div>
<div class="line">    readZipBlock(&amp;newlevel-&gt;fdh[0], l.levelheadersize, FaceDataHeaderSize * l.nfaces);</div>
<div class="line">    computeOffsets(tell(), l.nfaces, &amp;newlevel-&gt;fdh[0], &amp;newlevel-&gt;offsets[0]);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// apply edits (if any) to level 0</span></div>
<div class="line"> <span class="keywordflow">if</span> (levelid == 0) {</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0, size = _faceedits.size(); i &lt; <a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>; i++) {</div>
<div class="line">        FaceEdit&amp; e = _faceedits[i];</div>
<div class="line">        newlevel-&gt;fdh[e.faceid] = e.fdh;</div>
<div class="line">        newlevel-&gt;offsets[e.faceid] = e.pos;</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// don't assign to result until level data is fully initialized</span></div>
<div class="line">    _cache-&gt;cachelock.lock();</div>
<div class="line">    level = newlevel;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// clean up unused data</span></div>
<div class="line">    _cache-&gt;purgeData();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::readFace(<span class="keywordtype">int</span> levelid, Level* level, <span class="keywordtype">int</span> faceid)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// temporarily release cache lock so other threads can proceed</span></div>
<div class="line">    _cache-&gt;cachelock.unlock();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// get read lock and make sure we still need to read</span></div>
<div class="line">    FaceData*&amp; <a class="code" href="./_g_lee_8h.html#a676ca580c460c0154eb58200433d2a9e">face</a> = level-&gt;faces[faceid];</div>
<div class="line">    AutoMutex locker(readlock);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (face) {</div>
<div class="line"> <span class="comment">// another thread must have read it while we were waiting</span></div>
<div class="line">    _cache-&gt;cachelock.lock();</div>
<div class="line"> <span class="comment">// make sure it's still there now that we have the lock</span></div>
<div class="line"> <span class="keywordflow">if</span> (face) {</div>
<div class="line">        face-&gt;ref();</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    _cache-&gt;cachelock.unlock();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// Go ahead and read the face, and read nearby faces if</span></div>
<div class="line"> <span class="comment">// possible. The goal is to coalesce small faces into single</span></div>
<div class="line"> <span class="comment">// runs of consecutive reads to minimize seeking and take</span></div>
<div class="line"> <span class="comment">// advantage of read-ahead buffering.</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// Try to read as many faces as will fit in BlockSize.  Use the</span></div>
<div class="line"> <span class="comment">// in-memory size rather than the on-disk size to prevent flooding</span></div>
<div class="line"> <span class="comment">// the memory cache.  And don't coalesce w/ tiled faces as these</span></div>
<div class="line"> <span class="comment">// are meant to be read individually.</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// scan both backwards and forwards looking for unread faces</span></div>
<div class="line"> <span class="keywordtype">int</span> <a class="code" href="./_g_lee_8h.html#a970a385f6f880f2b620451db4ca4299a">first</a> = faceid, last = faceid;</div>
<div class="line"> <span class="keywordtype">int</span> totalsize = 0;</div>
<div class="line"></div>
<div class="line">    FaceDataHeader fdh = level-&gt;fdh[faceid];</div>
<div class="line"> <span class="keywordflow">if</span> (fdh.encoding() != enc_tiled) {</div>
<div class="line">    totalsize += unpackedSize(fdh, levelid, faceid);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> nfaces = <a name="a6"></a><a class="code" href="./_g_lee_8h.html#aa813ad7a4a00cda401ffd0c336154620">int</a>(level-&gt;fdh.size());</div>
<div class="line"> <span class="keywordflow">while</span> (1) {</div>
<div class="line"> <span class="keywordtype">int</span> f = first-1;</div>
<div class="line"> <span class="keywordflow">if</span> (<a class="code" href="./_g_lee_8h.html#a691492ec0bd6383f91200e49f6ae40ed">f &lt; 0 || level-&gt;</a>faces[f]) <span class="keywordflow">break</span>;</div>
<div class="line">        fdh = level-&gt;fdh[<a name="a7"></a><a class="code" href="./_g_lee_8h.html#a691492ec0bd6383f91200e49f6ae40ed">f</a>];</div>
<div class="line"> <span class="keywordflow">if</span> (fdh.encoding() == enc_tiled) <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordtype">int</span> size = totalsize + unpackedSize(fdh, levelid, f);</div>
<div class="line"> <span class="keywordflow">if</span> (size &gt; BlockSize) <span class="keywordflow">break</span>;</div>
<div class="line">        first = <a class="code" href="./_g_lee_8h.html#a691492ec0bd6383f91200e49f6ae40ed">f</a>;</div>
<div class="line">        totalsize = <a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">while</span> (1) {</div>
<div class="line"> <span class="keywordtype">int</span> f = last+1;</div>
<div class="line"> <span class="keywordflow">if</span> (f &gt;= nfaces || level-&gt;faces[f]) <span class="keywordflow">break</span>;</div>
<div class="line">        fdh = level-&gt;fdh[<a class="code" href="./_g_lee_8h.html#a691492ec0bd6383f91200e49f6ae40ed">f</a>];</div>
<div class="line"> <span class="keywordflow">if</span> (fdh.encoding() == enc_tiled) <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordtype">int</span> size = totalsize + unpackedSize(fdh, levelid, f);</div>
<div class="line"> <span class="keywordflow">if</span> (size &gt; BlockSize) <span class="keywordflow">break</span>;</div>
<div class="line">        last = <a class="code" href="./_g_lee_8h.html#a691492ec0bd6383f91200e49f6ae40ed">f</a>;</div>
<div class="line">        totalsize = <a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>;</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// read all faces in range</span></div>
<div class="line"> <span class="comment">// keep track of extra faces we read so we can add them to the cache later</span></div>
<div class="line">    std::vector&lt;FaceData*&gt; extraFaces;</div>
<div class="line">    extraFaces.reserve(last-first);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = first; i &lt;= last; i++) {</div>
<div class="line">    fdh = level-&gt;fdh[i];</div>
<div class="line"> <span class="comment">// skip faces with zero size (which is true for level-0 constant faces)</span></div>
<div class="line"> <span class="keywordflow">if</span> (fdh.blocksize()) {</div>
<div class="line">        FaceData*&amp; face = level-&gt;faces[i];</div>
<div class="line">        readFaceData(level-&gt;offsets[i], fdh, getRes(levelid, i), levelid, face);</div>
<div class="line"> <span class="keywordflow">if</span> (i != faceid) extraFaces.push_back(face);</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// reacquire cache lock, then unref extra faces to add them to the cache</span></div>
<div class="line">    _cache-&gt;cachelock.lock();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0, size = extraFaces.size(); i &lt; <a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>; i++)</div>
<div class="line">    extraFaces[i]-&gt;unref();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::TiledFace::readTile(<span class="keywordtype">int</span> tile, FaceData*&amp; data)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// temporarily release cache lock so other threads can proceed</span></div>
<div class="line">    _cache-&gt;cachelock.unlock();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// get read lock and make sure we still need to read</span></div>
<div class="line">    AutoMutex locker(_reader-&gt;readlock);</div>
<div class="line"> <span class="keywordflow">if</span> (data) {</div>
<div class="line"> <span class="comment">// another thread must have read it while we were waiting</span></div>
<div class="line">    _cache-&gt;cachelock.lock();</div>
<div class="line"> <span class="comment">// make sure it's still there now that we have the lock</span></div>
<div class="line"> <span class="keywordflow">if</span> (data) {</div>
<div class="line">        data-&gt;ref();</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    _cache-&gt;cachelock.unlock();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// go ahead and read the face data</span></div>
<div class="line">    _reader-&gt;readFaceData(_offsets[tile], _fdh[tile], _tileres, _levelid, data);</div>
<div class="line">    _cache-&gt;cachelock.lock();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// clean up unused data</span></div>
<div class="line">    _cache-&gt;purgeData();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::readFaceData(FilePos pos, FaceDataHeader fdh, Res <a class="code" href="./_g_lee_8h.html#a1dbb21208b9047cc8031ca9c840d3c2f">res</a>, <span class="keywordtype">int</span> levelid,</div>
<div class="line">                  FaceData*&amp; face)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// keep new face local until fully initialized</span></div>
<div class="line">    FaceData* <span class="keyword">volatile</span> newface = 0;</div>
<div class="line"></div>
<div class="line">    seek(pos);</div>
<div class="line"> <span class="keywordflow">switch</span> (fdh.encoding()) {</div>
<div class="line"> <span class="keywordflow">case</span> enc_constant:</div>
<div class="line">    {</div>
<div class="line">        ConstantFace* pf = <span class="keyword">new</span> ConstantFace((<span class="keywordtype">void</span>**)&amp;face, _cache, _pixelsize);</div>
<div class="line">        readBlock(pf-&gt;data(), _pixelsize);</div>
<div class="line"> <span class="keywordflow">if</span> (levelid==0 &amp;&amp; _premultiply &amp;&amp; _header.hasAlpha())</div>
<div class="line">        PtexUtils::multalpha(pf-&gt;data(), 1, _header.datatype,</div>
<div class="line">                     _header.nchannels, _header.alphachan);</div>
<div class="line">        newface = pf;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> enc_tiled:</div>
<div class="line">    {</div>
<div class="line">        Res tileres;</div>
<div class="line">        readBlock(&amp;tileres, <span class="keyword">sizeof</span>(tileres));</div>
<div class="line">        uint32_t tileheadersize;</div>
<div class="line">        readBlock(&amp;tileheadersize, <span class="keyword">sizeof</span>(tileheadersize));</div>
<div class="line">        TiledFace* tf = <span class="keyword">new</span> TiledFace((<span class="keywordtype">void</span>**)&amp;face, _cache, res, tileres, levelid, <span class="keyword">this</span>);</div>
<div class="line">        readZipBlock(&amp;tf-&gt;_fdh[0], tileheadersize, FaceDataHeaderSize * tf-&gt;_ntiles);</div>
<div class="line">        computeOffsets(tell(), tf-&gt;_ntiles, &amp;tf-&gt;_fdh[0], &amp;tf-&gt;_offsets[0]);</div>
<div class="line">        newface = tf;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line"> <span class="keywordflow">case</span> enc_zipped:</div>
<div class="line"> <span class="keywordflow">case</span> enc_diffzipped:</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordtype">int</span> uw = res.u(), vw = res.v();</div>
<div class="line"> <span class="keywordtype">int</span> npixels = uw * vw;</div>
<div class="line"> <span class="keywordtype">int</span> unpackedSize = _pixelsize * npixels;</div>
<div class="line">        PackedFace* pf = <span class="keyword">new</span> PackedFace((<span class="keywordtype">void</span>**)&amp;face, _cache,</div>
<div class="line">                        res, _pixelsize, unpackedSize);</div>
<div class="line"> <span class="keywordtype">void</span>* tmp = alloca(unpackedSize);</div>
<div class="line">        readZipBlock(tmp, fdh.blocksize(), unpackedSize);</div>
<div class="line"> <span class="keywordflow">if</span> (fdh.encoding() == enc_diffzipped)</div>
<div class="line">        PtexUtils::decodeDifference(tmp, unpackedSize, _header.datatype);</div>
<div class="line">        PtexUtils::interleave(tmp, uw * DataSize(_header.datatype), uw, vw,</div>
<div class="line">                  pf-&gt;data(), uw * _pixelsize,</div>
<div class="line">                  _header.datatype, _header.nchannels);</div>
<div class="line"> <span class="keywordflow">if</span> (levelid==0 &amp;&amp; _premultiply &amp;&amp; _header.hasAlpha())</div>
<div class="line">        PtexUtils::multalpha(pf-&gt;data(), npixels, _header.datatype,</div>
<div class="line">                     _header.nchannels, _header.alphachan);</div>
<div class="line">        newface = pf;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    face = newface;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::getData(<span class="keywordtype">int</span> faceid, <span class="keywordtype">void</span>* <a class="code" href="./_g_lee_8h.html#a3667f558219c90437106b544a3ca00b8">buffer</a>, <span class="keywordtype">int</span> <a class="code" href="./_g_lee_8h.html#a9d21c1b0530d07b637b5b71b969d7921">stride</a>)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!_ok) <span class="keywordflow">return</span>;</div>
<div class="line">    FaceInfo&amp; f = _faceinfo[faceid];</div>
<div class="line">    getData(faceid, buffer, stride, f.res);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::getData(<span class="keywordtype">int</span> faceid, <span class="keywordtype">void</span>* buffer, <span class="keywordtype">int</span> stride, Res res)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!_ok) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// note - all locking is handled in called getData methods</span></div>
<div class="line">    FaceInfo&amp; f = _faceinfo[faceid];</div>
<div class="line"> <span class="keywordtype">int</span> resu = res.u(), resv = res.v();</div>
<div class="line"> <span class="keywordtype">int</span> rowlen = _pixelsize * resu;</div>
<div class="line"> <span class="keywordflow">if</span> (stride == 0) stride = rowlen;</div>
<div class="line"></div>
<div class="line">    PtexPtr&lt;PtexFaceData&gt; d ( getData(faceid, res) );</div>
<div class="line"> <span class="keywordflow">if</span> (!d) <span class="keywordflow">return</span>;</div>
<div class="line"> <span class="keywordflow">if</span> (d-&gt;isConstant()) {</div>
<div class="line"> <span class="comment">// fill dest buffer with pixel value</span></div>
<div class="line">    PtexUtils::fill(d-&gt;getData(), <a name="a8"></a><a class="code" href="./_g_lee_8h.html#a3667f558219c90437106b544a3ca00b8">buffer</a>, <a name="a9"></a><a class="code" href="./_g_lee_8h.html#a9d21c1b0530d07b637b5b71b969d7921">stride</a>,</div>
<div class="line">            resu, resv, _pixelsize);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (d-&gt;isTiled()) {</div>
<div class="line"> <span class="comment">// loop over tiles</span></div>
<div class="line">    Res tileres = d-&gt;tileRes();</div>
<div class="line"> <span class="keywordtype">int</span> ntilesu = f.res.ntilesu(tileres);</div>
<div class="line"> <span class="keywordtype">int</span> ntilesv = f.res.ntilesv(tileres);</div>
<div class="line"> <span class="keywordtype">int</span> tileures = tileres.u();</div>
<div class="line"> <span class="keywordtype">int</span> tilevres = tileres.v();</div>
<div class="line"> <span class="keywordtype">int</span> tilerowlen = _pixelsize * tileures;</div>
<div class="line"> <span class="keywordtype">int</span> tile = 0;</div>
<div class="line"> <span class="keywordtype">char</span>* dsttilerow = (<span class="keywordtype">char</span>*) buffer;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ntilesv; i++) {</div>
<div class="line"> <span class="keywordtype">char</span>* dsttile = dsttilerow;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; ntilesu; j++) {</div>
<div class="line">        PtexPtr&lt;PtexFaceData&gt; <a name="a10"></a><a class="code" href="./_g_lee_8h.html#a653819996e713edf9c01a5b564199189">t</a> ( d-&gt;getTile(tile++) );</div>
<div class="line"> <span class="keywordflow">if</span> (!<a class="code" href="./_g_lee_8h.html#a653819996e713edf9c01a5b564199189">t</a>) { i = ntilesv; <span class="keywordflow">break</span>; }</div>
<div class="line"> <span class="keywordflow">if</span> (<a class="code" href="./_g_lee_8h.html#a653819996e713edf9c01a5b564199189">t</a>-&gt;isConstant())</div>
<div class="line">            PtexUtils::fill(<a class="code" href="./_g_lee_8h.html#a653819996e713edf9c01a5b564199189">t</a>-&gt;getData(), dsttile, <a class="code" href="./_g_lee_8h.html#a9d21c1b0530d07b637b5b71b969d7921">stride</a>,</div>
<div class="line">                    tileures, tilevres, _pixelsize);</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">            PtexUtils::copy(<a class="code" href="./_g_lee_8h.html#a653819996e713edf9c01a5b564199189">t</a>-&gt;getData(), tilerowlen, dsttile, <a class="code" href="./_g_lee_8h.html#a9d21c1b0530d07b637b5b71b969d7921">stride</a>,</div>
<div class="line">                    tilevres, tilerowlen);</div>
<div class="line">        dsttile += tilerowlen;</div>
<div class="line">        }</div>
<div class="line">        dsttilerow += stride * tilevres;</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">    PtexUtils::copy(d-&gt;getData(), rowlen, <a class="code" href="./_g_lee_8h.html#a3667f558219c90437106b544a3ca00b8">buffer</a>, <a class="code" href="./_g_lee_8h.html#a9d21c1b0530d07b637b5b71b969d7921">stride</a>, resv, rowlen);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">PtexFaceData* PtexReader::getData(<span class="keywordtype">int</span> faceid)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (faceid &lt; 0 || <span class="keywordtype">size_t</span>(faceid) &gt;= _header.nfaces) <span class="keywordflow">return</span> 0;</div>
<div class="line"> <span class="keywordflow">if</span> (!_ok) <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line">    FaceInfo&amp; fi = _faceinfo[faceid];</div>
<div class="line"> <span class="keywordflow">if</span> (fi.isConstant() || fi.res == 0) {</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">new</span> ConstDataPtr(getConstData() + faceid * _pixelsize, _pixelsize);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// get level zero (full) res face</span></div>
<div class="line">    AutoLockCache locker(_cache-&gt;cachelock);</div>
<div class="line">    Level* level = getLevel(0);</div>
<div class="line">    FaceData* face = getFace(0, level, faceid);</div>
<div class="line">    level-&gt;unref();</div>
<div class="line"> <span class="keywordflow">return</span> <a name="a11"></a><a class="code" href="./_g_lee_8h.html#a676ca580c460c0154eb58200433d2a9e">face</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">PtexFaceData* PtexReader::getData(<span class="keywordtype">int</span> faceid, Res res)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordflow">if</span> (!_ok) <span class="keywordflow">return</span> 0;</div>
<div class="line"> <span class="keywordflow">if</span> (faceid &lt; 0 || <span class="keywordtype">size_t</span>(faceid) &gt;= _header.nfaces) <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line">    FaceInfo&amp; fi = _faceinfo[faceid];</div>
<div class="line"> <span class="keywordflow">if</span> ((fi.isConstant() &amp;&amp; res &gt;= 0) || res == 0) {</div>
<div class="line"> <span class="keywordflow">return</span> <span class="keyword">new</span> ConstDataPtr(getConstData() + faceid * _pixelsize, _pixelsize);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// lock cache (can't autolock since we might need to unlock early)</span></div>
<div class="line">    _cache-&gt;cachelock.lock();</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="comment">// determine how many reduction levels are needed</span></div>
<div class="line"> <span class="keywordtype">int</span> redu = fi.res.ulog2 - res.ulog2, redv = fi.res.vlog2 - res.vlog2;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (redu == 0 &amp;&amp; redv == 0) {</div>
<div class="line"> <span class="comment">// no reduction - get level zero (full) res face</span></div>
<div class="line">    Level* level = getLevel(0);</div>
<div class="line">    FaceData* face = getFace(0, level, faceid);</div>
<div class="line">    level-&gt;unref();</div>
<div class="line">    _cache-&gt;cachelock.unlock();</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./_g_lee_8h.html#a676ca580c460c0154eb58200433d2a9e">face</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (redu == redv &amp;&amp; !fi.hasEdits() &amp;&amp; res &gt;= 0) {</div>
<div class="line"> <span class="comment">// reduction is symmetric and non-negative</span></div>
<div class="line"> <span class="comment">// and face has no edits =&gt; access data from reduction level (if present)</span></div>
<div class="line"> <span class="keywordtype">int</span> levelid = redu;</div>
<div class="line"> <span class="keywordflow">if</span> (<span class="keywordtype">size_t</span>(levelid) &lt; _levels.size()) {</div>
<div class="line">        Level* level = getLevel(levelid);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// get reduction face id</span></div>
<div class="line"> <span class="keywordtype">int</span> rfaceid = _rfaceids[faceid];</div>
<div class="line"></div>
<div class="line"> <span class="comment">// get the face data (if present)</span></div>
<div class="line">        FaceData* face = 0;</div>
<div class="line"> <span class="keywordflow">if</span> (<span class="keywordtype">size_t</span>(rfaceid) &lt; level-&gt;faces.size())</div>
<div class="line">        face = getFace(levelid, level, rfaceid);</div>
<div class="line">        level-&gt;unref();</div>
<div class="line"> <span class="keywordflow">if</span> (face) {</div>
<div class="line">        _cache-&gt;cachelock.unlock();</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./_g_lee_8h.html#a676ca580c460c0154eb58200433d2a9e">face</a>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// dynamic reduction required - look in dynamic reduction cache</span></div>
<div class="line">    FaceData*&amp; face = _reductions[ReductionKey(faceid, res)];</div>
<div class="line"> <span class="keywordflow">if</span> (face) {</div>
<div class="line">    face-&gt;ref();</div>
<div class="line">    _cache-&gt;cachelock.unlock();</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./_g_lee_8h.html#a676ca580c460c0154eb58200433d2a9e">face</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// not found,  generate new reduction</span></div>
<div class="line"> <span class="comment">// unlock cache - getData and reduce will handle their own locking</span></div>
<div class="line">    _cache-&gt;cachelock.unlock();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (res.ulog2 &lt; 0 || res.vlog2 &lt; 0) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"PtexReader::getData - reductions below 1 pixel not supported"</span> &lt;&lt; <a name="a12"></a><a class="code" href="./qtextstream_8h.html#ad61c42fcbf3cb355a75ddd5216d12ace">std::endl</a>;</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (redu &lt; 0 || redv &lt; 0) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"PtexReader::getData - enlargements not supported"</span> &lt;&lt; <a class="code" href="./qtextstream_8h.html#ad61c42fcbf3cb355a75ddd5216d12ace">std::endl</a>;</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (_header.meshtype == mt_triangle)</div>
<div class="line">    {</div>
<div class="line"> <span class="keywordflow">if</span> (redu != redv) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">"PtexReader::getData - anisotropic reductions not supported for triangle mesh"</span> &lt;&lt; <a class="code" href="./qtextstream_8h.html#ad61c42fcbf3cb355a75ddd5216d12ace">std::endl</a>;</div>
<div class="line"> <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">    PtexPtr&lt;PtexFaceData&gt; psrc ( getData(faceid, Res(res.ulog2+1, res.vlog2+1)) );</div>
<div class="line">    FaceData* <a class="code" href="./_g_lee_8h.html#a72e0fdf0f845ded60b1fada9e9195cd7">src</a> = <span class="keyword">dynamic_cast&lt;</span>FaceData*<span class="keyword">&gt;</span>(psrc.get());</div>
<div class="line">    assert(src);</div>
<div class="line"> <span class="keywordflow">if</span> (src) src-&gt;reduce(face, <span class="keyword">this</span>, res, PtexUtils::reduceTri);</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./_g_lee_8h.html#a676ca580c460c0154eb58200433d2a9e">face</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// determine which direction to blend</span></div>
<div class="line"> <span class="keywordtype">bool</span> blendu;</div>
<div class="line"> <span class="keywordflow">if</span> (redu == redv) {</div>
<div class="line"> <span class="comment">// for symmetric face blends, alternate u and v blending</span></div>
<div class="line">    blendu = (res.ulog2 &amp; 1);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> blendu = redu &gt; redv;</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (blendu) {</div>
<div class="line"> <span class="comment">// get next-higher u-res and reduce in u</span></div>
<div class="line">    PtexPtr&lt;PtexFaceData&gt; psrc ( getData(faceid, Res(res.ulog2+1, res.vlog2)) );</div>
<div class="line">    FaceData* src = <span class="keyword">dynamic_cast&lt;</span>FaceData*<span class="keyword">&gt;</span>(psrc.get());</div>
<div class="line">    assert(src);</div>
<div class="line"> <span class="keywordflow">if</span> (src) src-&gt;reduce(face, <span class="keyword">this</span>, res, PtexUtils::reduceu);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// get next-higher v-res and reduce in v</span></div>
<div class="line">    PtexPtr&lt;PtexFaceData&gt; psrc ( getData(faceid, Res(res.ulog2, res.vlog2+1)) );</div>
<div class="line">    FaceData* src = <span class="keyword">dynamic_cast&lt;</span>FaceData*<span class="keyword">&gt;</span>(psrc.get());</div>
<div class="line">    assert(src);</div>
<div class="line"> <span class="keywordflow">if</span> (src) src-&gt;reduce(face, <span class="keyword">this</span>, res, PtexUtils::reducev);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./_g_lee_8h.html#a676ca580c460c0154eb58200433d2a9e">face</a>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::blendFaces(FaceData*&amp; face, <span class="keywordtype">int</span> faceid, Res res, <span class="keywordtype">bool</span> blendu)</div>
<div class="line">{</div>
<div class="line">    Res pres;   <span class="comment">// parent res, 1 higher in blend direction</span></div>
<div class="line"> <span class="keywordtype">int</span> <a name="a13"></a><a class="code" href="./_g_lee_8h.html#a3c8469415bbc83dd1341af15c67f1cef">length</a>; <span class="comment">// length of blend edge (1xN or Nx1)</span></div>
<div class="line"> <span class="keywordtype">int</span> e1, e2; <span class="comment">// neighboring edge ids</span></div>
<div class="line"> <span class="keywordflow">if</span> (blendu) {</div>
<div class="line">    assert(res.ulog2 &lt; 0); <span class="comment">// res &gt;= 0 requires reduction, not blending</span></div>
<div class="line">    length = (res.vlog2 &lt;= 0 ? 1 : res.v());</div>
<div class="line">    e1 = e_bottom; e2 = e_top;</div>
<div class="line">    pres = Res(res.ulog2+1, res.vlog2);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line">    assert(res.vlog2 &lt; 0);</div>
<div class="line">    length = (res.ulog2 &lt;= 0 ? 1 : res.u());</div>
<div class="line">    e1 = e_right; e2 = e_left;</div>
<div class="line">    pres = Res(res.ulog2, res.vlog2+1);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// get neighbor face ids</span></div>
<div class="line">    FaceInfo&amp; f = _faceinfo[faceid];</div>
<div class="line"> <span class="keywordtype">int</span> nf1 = f.adjfaces[e1], nf2 = f.adjfaces[e2];</div>
<div class="line"></div>
<div class="line"> <span class="comment">// compute rotation of faces relative to current</span></div>
<div class="line"> <span class="keywordtype">int</span> r1 = (f.adjedge(e1)-e1+2)&amp;3;</div>
<div class="line"> <span class="keywordtype">int</span> r2 = (f.adjedge(e2)-e2+2)&amp;3;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// swap u and v res for faces rotated +/- 90 degrees</span></div>
<div class="line">    Res pres1 = pres, pres2 = pres;</div>
<div class="line"> <span class="keywordflow">if</span> (r1 &amp; 1) pres1.swapuv();</div>
<div class="line"> <span class="keywordflow">if</span> (r2 &amp; 1) pres2.swapuv();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// ignore faces that have insufficient res (unlikely, but possible)</span></div>
<div class="line"> <span class="keywordflow">if</span> (nf1 &gt;= 0 &amp;&amp; !(_faceinfo[nf1].res &gt;= pres)) nf1 = -1;</div>
<div class="line"> <span class="keywordflow">if</span> (nf2 &gt;= 0 &amp;&amp; !(_faceinfo[nf2].res &gt;= pres)) nf2 = -1;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// get parent face data</span></div>
<div class="line"> <span class="keywordtype">int</span> nf = 1;         <span class="comment">// number of faces to blend (1 to 3)</span></div>
<div class="line"> <span class="keywordtype">bool</span> flip[3];       <span class="comment">// true if long dimension needs to be flipped</span></div>
<div class="line">    PtexFaceData* psrc[3];  <span class="comment">// the face data</span></div>
<div class="line">    psrc[0] = getData(faceid, pres);</div>
<div class="line">    flip[0] = 0;        <span class="comment">// don't flip main face</span></div>
<div class="line"> <span class="keywordflow">if</span> (nf1 &gt;= 0) {</div>
<div class="line"> <span class="comment">// face must be flipped if rot is 1 or 2 for blendu, or 2 or 3 for blendv</span></div>
<div class="line"> <span class="comment">// thus, just add the blendu bool val to align the ranges and check bit 1</span></div>
<div class="line"> <span class="comment">// also, no need to flip if length is zero</span></div>
<div class="line">    flip[nf] = length ? (r1 + blendu) &amp; 1 : 0;</div>
<div class="line">    psrc[nf++] = getData(nf1, pres1);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (nf2 &gt;= 0) {</div>
<div class="line">    flip[nf] = length ? (r2 + blendu) &amp; 1 : 0;</div>
<div class="line">    psrc[nf++] = getData(nf2, pres2);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// get reduce lock and make sure we still need to reduce</span></div>
<div class="line">    AutoMutex rlocker(reducelock);</div>
<div class="line"> <span class="keywordflow">if</span> (face) {</div>
<div class="line"> <span class="comment">// another thread must have generated it while we were waiting</span></div>
<div class="line">    AutoLockCache locker(_cache-&gt;cachelock);</div>
<div class="line"> <span class="comment">// make sure it's still there now that we have the lock</span></div>
<div class="line"> <span class="keywordflow">if</span> (face) {</div>
<div class="line">        face-&gt;ref();</div>
<div class="line"> <span class="comment">// release parent data</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nf; i++) psrc[i]-&gt;release();</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// allocate a new face data (1 x N or N x 1)</span></div>
<div class="line">    DataType dt = datatype();</div>
<div class="line"> <span class="keywordtype">int</span> nchan = nchannels();</div>
<div class="line"> <span class="keywordtype">int</span> size = _pixelsize * <a class="code" href="./_g_lee_8h.html#a3c8469415bbc83dd1341af15c67f1cef">length</a>;</div>
<div class="line">    PackedFace* pf = <span class="keyword">new</span> PackedFace((<span class="keywordtype">void</span>**)&amp;face, _cache, res,</div>
<div class="line">                    _pixelsize, size);</div>
<div class="line"> <span class="keywordtype">void</span>* data = pf-&gt;getData();</div>
<div class="line"> <span class="keywordflow">if</span> (nf == 1) {</div>
<div class="line"> <span class="comment">// no neighbors - just copy face</span></div>
<div class="line">    memcpy(data, psrc[0]-&gt;getData(), size);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="keywordtype">float</span> weight = 1.0f / nf;</div>
<div class="line">    memset(data, 0, size);</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nf; i++)</div>
<div class="line">        PtexUtils::blend(psrc[i]-&gt;getData(), weight, data, flip[i],</div>
<div class="line">                 length, dt, nchan);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    {</div>
<div class="line">    AutoLockCache clocker(_cache-&gt;cachelock);</div>
<div class="line">    face = pf;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// clean up unused data</span></div>
<div class="line">    _cache-&gt;purgeData();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// release parent data</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nf; i++) psrc[i]-&gt;release();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::getPixel(<span class="keywordtype">int</span> faceid, <span class="keywordtype">int</span> u, <span class="keywordtype">int</span> <a class="code" href="./_g_lee_8h.html#a14cfbe2fc2234f5504618905b69d1e06">v</a>,</div>
<div class="line"> <span class="keywordtype">float</span>* result, <span class="keywordtype">int</span> firstchan, <span class="keywordtype">int</span> nchannels)</div>
<div class="line">{</div>
<div class="line">    memset(result, 0, nchannels);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// clip nchannels against actual number available</span></div>
<div class="line">    nchannels = PtexUtils::min(nchannels,</div>
<div class="line">                   _header.nchannels-firstchan);</div>
<div class="line"> <span class="keywordflow">if</span> (nchannels &lt;= 0) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// get raw pixel data</span></div>
<div class="line">    PtexPtr&lt;PtexFaceData&gt; <a name="a14"></a><a class="code" href="./_g_lee_8h.html#a2cc7c8468af76cf855e1755c27945693">data</a> ( getData(faceid) );</div>
<div class="line"> <span class="keywordflow">if</span> (!data) <span class="keywordflow">return</span>;</div>
<div class="line"> <span class="keywordtype">void</span>* pixel = alloca(_pixelsize);</div>
<div class="line">    data-&gt;getPixel(u, v, pixel);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// adjust for firstchan offset</span></div>
<div class="line"> <span class="keywordtype">int</span> datasize = DataSize(_header.datatype);</div>
<div class="line"> <span class="keywordflow">if</span> (firstchan)</div>
<div class="line">    pixel = (<span class="keywordtype">char</span>*) pixel + datasize * firstchan;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// convert/copy to result as needed</span></div>
<div class="line"> <span class="keywordflow">if</span> (_header.datatype == dt_float)</div>
<div class="line">    memcpy(result, pixel, datasize * nchannels);</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">    ConvertToFloat(result, pixel, _header.datatype, nchannels);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::getPixel(<span class="keywordtype">int</span> faceid, <span class="keywordtype">int</span> u, <span class="keywordtype">int</span> v,</div>
<div class="line"> <span class="keywordtype">float</span>* result, <span class="keywordtype">int</span> firstchan, <span class="keywordtype">int</span> nchannels,</div>
<div class="line">              Ptex::Res res)</div>
<div class="line">{</div>
<div class="line">    memset(result, 0, nchannels);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// clip nchannels against actual number available</span></div>
<div class="line">    nchannels = PtexUtils::min(nchannels,</div>
<div class="line">                   _header.nchannels-firstchan);</div>
<div class="line"> <span class="keywordflow">if</span> (nchannels &lt;= 0) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// get raw pixel data</span></div>
<div class="line">    PtexPtr&lt;PtexFaceData&gt; <a class="code" href="./_g_lee_8h.html#a2cc7c8468af76cf855e1755c27945693">data</a> ( getData(faceid, res) );</div>
<div class="line"> <span class="keywordflow">if</span> (!data) <span class="keywordflow">return</span>;</div>
<div class="line"> <span class="keywordtype">void</span>* pixel = alloca(_pixelsize);</div>
<div class="line">    data-&gt;getPixel(u, v, pixel);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// adjust for firstchan offset</span></div>
<div class="line"> <span class="keywordtype">int</span> datasize = DataSize(_header.datatype);</div>
<div class="line"> <span class="keywordflow">if</span> (firstchan)</div>
<div class="line">    pixel = (<span class="keywordtype">char</span>*) pixel + datasize * firstchan;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// convert/copy to result as needed</span></div>
<div class="line"> <span class="keywordflow">if</span> (_header.datatype == dt_float)</div>
<div class="line">    memcpy(result, pixel, datasize * nchannels);</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">    ConvertToFloat(result, pixel, _header.datatype, nchannels);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::PackedFace::reduce(FaceData*&amp; face, PtexReader* <a class="code" href="./_g_lee_8h.html#a28666c5860e73f899079b4ee29200aec">r</a>,</div>
<div class="line">                    Res newres, PtexUtils::ReduceFn reducefn)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// get reduce lock and make sure we still need to reduce</span></div>
<div class="line">    AutoMutex rlocker(r-&gt;reducelock);</div>
<div class="line"> <span class="keywordflow">if</span> (face) {</div>
<div class="line"> <span class="comment">// another thread must have generated it while we were waiting</span></div>
<div class="line">    AutoLockCache clocker(_cache-&gt;cachelock);</div>
<div class="line"> <span class="comment">// make sure it's still there now that we have the lock</span></div>
<div class="line"> <span class="keywordflow">if</span> (face) {</div>
<div class="line">        face-&gt;ref();</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// allocate a new face and reduce image</span></div>
<div class="line">    DataType dt = r-&gt;datatype();</div>
<div class="line"> <span class="keywordtype">int</span> nchan = r-&gt;nchannels();</div>
<div class="line">    PackedFace* pf = <span class="keyword">new</span> PackedFace((<span class="keywordtype">void</span>**)&amp;face, _cache, newres,</div>
<div class="line">                    _pixelsize, _pixelsize * newres.size());</div>
<div class="line"> <span class="comment">// reduce and copy into new face</span></div>
<div class="line">    reducefn(_data, _pixelsize * _res.u(), _res.u(), _res.v(),</div>
<div class="line">         pf-&gt;_data, _pixelsize * newres.u(), dt, nchan);</div>
<div class="line">    AutoLockCache clocker(_cache-&gt;cachelock);</div>
<div class="line">    face = pf;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// clean up unused data</span></div>
<div class="line">    _cache-&gt;purgeData();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::ConstantFace::reduce(FaceData*&amp; face, PtexReader*,</div>
<div class="line">                      Res, PtexUtils::ReduceFn)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// get cache lock (just to protect the ref count)</span></div>
<div class="line">    AutoLockCache locker(_cache-&gt;cachelock);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// must make a new constant face (even though it's identical to this one)</span></div>
<div class="line"> <span class="comment">// because it will be owned by a different reduction level</span></div>
<div class="line"> <span class="comment">// and will therefore have a different parent</span></div>
<div class="line">    ConstantFace* pf = <span class="keyword">new</span> ConstantFace((<span class="keywordtype">void</span>**)&amp;face, _cache, _pixelsize);</div>
<div class="line">    memcpy(pf-&gt;_data, _data, _pixelsize);</div>
<div class="line">    face = pf;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::TiledFaceBase::reduce(FaceData*&amp; face, PtexReader* r,</div>
<div class="line">                       Res newres, PtexUtils::ReduceFn reducefn)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// get reduce lock and make sure we still need to reduce</span></div>
<div class="line">    AutoMutex rlocker(r-&gt;reducelock);</div>
<div class="line"> <span class="keywordflow">if</span> (face) {</div>
<div class="line"> <span class="comment">// another thread must have generated it while we were waiting</span></div>
<div class="line">    AutoLockCache clocker(_cache-&gt;cachelock);</div>
<div class="line"> <span class="comment">// make sure it's still there now that we have the lock</span></div>
<div class="line"> <span class="keywordflow">if</span> (face) {</div>
<div class="line">        face-&gt;ref();</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">/* Tiled reductions should generally only be anisotropic (just u</span></div>
<div class="line"><span class="comment">       or v, not both) since isotropic reductions are precomputed and</span></div>
<div class="line"><span class="comment">       stored on disk.  (This function should still work for isotropic</span></div>
<div class="line"><span class="comment">       reductions though.)</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">       In the anisotropic case, the number of tiles should be kept the</span></div>
<div class="line"><span class="comment">       same along the direction not being reduced in order to preserve</span></div>
<div class="line"><span class="comment">       the laziness of the file access.  In contrast, if reductions</span></div>
<div class="line"><span class="comment">       were not tiled, then any reduction would read all the tiles and</span></div>
<div class="line"><span class="comment">       defeat the purpose of tiling.</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// keep new face local until fully initialized</span></div>
<div class="line">    FaceData* <span class="keyword">volatile</span> newface = 0;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// don't tile if either dimension is 1 (rare, would complicate blendFaces too much)</span></div>
<div class="line">    Res newtileres;</div>
<div class="line"> <span class="keywordflow">if</span> (newres.ulog2 == 1 || newres.vlog2 == 1) {</div>
<div class="line">    newtileres = newres;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// propagate the tile res to the reduction</span></div>
<div class="line">    newtileres = _tileres;</div>
<div class="line"> <span class="comment">// but make sure tile isn't larger than the new face!</span></div>
<div class="line"> <span class="keywordflow">if</span> (newtileres.ulog2 &gt; newres.ulog2) newtileres.ulog2 = newres.ulog2;</div>
<div class="line"> <span class="keywordflow">if</span> (newtileres.vlog2 &gt; newres.vlog2) newtileres.vlog2 = newres.vlog2;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="comment">// determine how many tiles we will have on the reduction</span></div>
<div class="line"> <span class="keywordtype">int</span> newntiles = newres.ntiles(newtileres);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (newntiles == 1) {</div>
<div class="line"> <span class="comment">// no need to keep tiling, reduce tiles into a single face</span></div>
<div class="line"> <span class="comment">// first, get all tiles and check if they are constant (with the same value)</span></div>
<div class="line">    PtexFaceData** tiles = (PtexFaceData**) alloca(_ntiles * <span class="keyword">sizeof</span>(PtexFaceData*));</div>
<div class="line"> <span class="keywordtype">bool</span> allConstant = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; _ntiles; i++) {</div>
<div class="line">        PtexFaceData* tile = tiles[i] = getTile(i);</div>
<div class="line">        allConstant = (allConstant &amp;&amp; tile-&gt;isConstant() &amp;&amp;</div>
<div class="line">               (i == 0 || (0 == memcmp(tiles[0]-&gt;getData(), tile-&gt;getData(),</div>
<div class="line">                           _pixelsize))));</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (allConstant) {</div>
<div class="line"> <span class="comment">// allocate a new constant face</span></div>
<div class="line">        newface = <span class="keyword">new</span> ConstantFace((<span class="keywordtype">void</span>**)&amp;face, _cache, _pixelsize);</div>
<div class="line">        memcpy(newface-&gt;getData(), tiles[0]-&gt;getData(), _pixelsize);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// allocate a new packed face</span></div>
<div class="line">        newface = <span class="keyword">new</span> PackedFace((<span class="keywordtype">void</span>**)&amp;face, _cache, newres,</div>
<div class="line">                     _pixelsize, _pixelsize*newres.size());</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> tileures = _tileres.u();</div>
<div class="line"> <span class="keywordtype">int</span> tilevres = _tileres.v();</div>
<div class="line"> <span class="keywordtype">int</span> sstride = _pixelsize * tileures;</div>
<div class="line"> <span class="keywordtype">int</span> dstride = _pixelsize * newres.u();</div>
<div class="line"> <span class="keywordtype">int</span> dstepu = dstride/_ntilesu;</div>
<div class="line"> <span class="keywordtype">int</span> dstepv = dstride*newres.v()/_ntilesv - dstepu*(_ntilesu-1);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">char</span>* <a class="code" href="./_g_lee_8h.html#a92034251bfd455d524a9b5610cddba00">dst</a> = (<span class="keywordtype">char</span>*) newface-&gt;getData();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; _ntiles;) {</div>
<div class="line">        PtexFaceData* tile = tiles[i];</div>
<div class="line"> <span class="keywordflow">if</span> (tile-&gt;isConstant())</div>
<div class="line">            PtexUtils::fill(tile-&gt;getData(), <a name="a15"></a><a class="code" href="./_g_lee_8h.html#a92034251bfd455d524a9b5610cddba00">dst</a>, dstride,</div>
<div class="line">                    newres.u()/_ntilesu, newres.v()/_ntilesv,</div>
<div class="line">                    _pixelsize);</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">            reducefn(tile-&gt;getData(), sstride, tileures, tilevres,</div>
<div class="line"> <a class="code" href="./_g_lee_8h.html#a92034251bfd455d524a9b5610cddba00">dst</a>, dstride, _dt, _nchan);</div>
<div class="line">        i++;</div>
<div class="line">        dst += i%_ntilesu ? dstepu : dstepv;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="comment">// release the tiles</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; _ntiles; i++) tiles[i]-&gt;release();</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// otherwise, tile the reduced face</span></div>
<div class="line">    newface = <span class="keyword">new</span> TiledReducedFace((<span class="keywordtype">void</span>**)&amp;face, _cache, newres, newtileres,</div>
<div class="line">                       _dt, _nchan, <span class="keyword">this</span>, reducefn);</div>
<div class="line">    }</div>
<div class="line">    AutoLockCache clocker(_cache-&gt;cachelock);</div>
<div class="line">    face = newface;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// clean up unused data</span></div>
<div class="line">    _cache-&gt;purgeData();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexReader::TiledFaceBase::getPixel(<span class="keywordtype">int</span> ui, <span class="keywordtype">int</span> vi, <span class="keywordtype">void</span>* result)</div>
<div class="line">{</div>
<div class="line"> <span class="keywordtype">int</span> tileu = ui &gt;&gt; _tileres.ulog2;</div>
<div class="line"> <span class="keywordtype">int</span> tilev = vi &gt;&gt; _tileres.vlog2;</div>
<div class="line">    PtexPtr&lt;PtexFaceData&gt; tile ( getTile(tilev * _ntilesu + tileu) );</div>
<div class="line">    tile-&gt;getPixel(ui - (tileu&lt;&lt;_tileres.ulog2),</div>
<div class="line">           vi - (tilev&lt;&lt;_tileres.vlog2), result);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">PtexFaceData* PtexReader::TiledReducedFace::getTile(<span class="keywordtype">int</span> tile)</div>
<div class="line">{</div>
<div class="line">    _cache-&gt;cachelock.lock();</div>
<div class="line">    FaceData*&amp; face = _tiles[tile];</div>
<div class="line"> <span class="keywordflow">if</span> (face) {</div>
<div class="line">    face-&gt;ref();</div>
<div class="line">    _cache-&gt;cachelock.unlock();</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./_g_lee_8h.html#a676ca580c460c0154eb58200433d2a9e">face</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// first, get all parent tiles for this tile</span></div>
<div class="line"> <span class="comment">// and check if they are constant (with the same value)</span></div>
<div class="line"> <span class="keywordtype">int</span> pntilesu = _parentface-&gt;ntilesu();</div>
<div class="line"> <span class="keywordtype">int</span> pntilesv = _parentface-&gt;ntilesv();</div>
<div class="line"> <span class="keywordtype">int</span> nu = pntilesu / _ntilesu; <span class="comment">// num parent tiles for this tile in u dir</span></div>
<div class="line"> <span class="keywordtype">int</span> nv = pntilesv / _ntilesv; <span class="comment">// num parent tiles for this tile in v dir</span></div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> ntiles = nu*nv; <span class="comment">// num parent tiles for this tile</span></div>
<div class="line">    PtexFaceData** tiles = (PtexFaceData**) alloca(ntiles * <span class="keyword">sizeof</span>(PtexFaceData*));</div>
<div class="line"> <span class="keywordtype">bool</span> allConstant = <span class="keyword">true</span>;</div>
<div class="line"> <span class="keywordtype">int</span> ptile = (tile/_ntilesu) * nv * pntilesu + (tile%_ntilesu) * nu;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ntiles;) {</div>
<div class="line"> <span class="comment">// temporarily release cache lock while we get parent tile</span></div>
<div class="line">    _cache-&gt;cachelock.unlock();</div>
<div class="line">    PtexFaceData* tile = tiles[i] = _parentface-&gt;getTile(ptile);</div>
<div class="line">    _cache-&gt;cachelock.lock();</div>
<div class="line">    allConstant = (allConstant &amp;&amp; tile-&gt;isConstant() &amp;&amp;</div>
<div class="line">               (i==0 || (0 == memcmp(tiles[0]-&gt;getData(), tile-&gt;getData(),</div>
<div class="line">                         _pixelsize))));</div>
<div class="line">    i++;</div>
<div class="line">    ptile += i%nu? 1 : pntilesu - nu + 1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// make sure another thread didn't make the tile while we were checking</span></div>
<div class="line"> <span class="keywordflow">if</span> (face) {</div>
<div class="line">    face-&gt;ref();</div>
<div class="line">    _cache-&gt;cachelock.unlock();</div>
<div class="line"> <span class="comment">// release the tiles</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ntiles; i++) tiles[i]-&gt;release();</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./_g_lee_8h.html#a676ca580c460c0154eb58200433d2a9e">face</a>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (allConstant) {</div>
<div class="line"> <span class="comment">// allocate a new constant face</span></div>
<div class="line">    face = <span class="keyword">new</span> ConstantFace((<span class="keywordtype">void</span>**)&amp;face, _cache, _pixelsize);</div>
<div class="line">    memcpy(face-&gt;getData(), tiles[0]-&gt;getData(), _pixelsize);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// allocate a new packed face for the tile</span></div>
<div class="line">    face = <span class="keyword">new</span> PackedFace((<span class="keywordtype">void</span>**)&amp;face, _cache, _tileres,</div>
<div class="line">                  _pixelsize, _pixelsize*_tileres.size());</div>
<div class="line"></div>
<div class="line"> <span class="comment">// generate reduction from parent tiles</span></div>
<div class="line"> <span class="keywordtype">int</span> ptileures = _parentface-&gt;tileres().u();</div>
<div class="line"> <span class="keywordtype">int</span> ptilevres = _parentface-&gt;tileres().v();</div>
<div class="line"> <span class="keywordtype">int</span> sstride = ptileures * _pixelsize;</div>
<div class="line"> <span class="keywordtype">int</span> dstride = _tileres.u() * _pixelsize;</div>
<div class="line"> <span class="keywordtype">int</span> dstepu = dstride/nu;</div>
<div class="line"> <span class="keywordtype">int</span> dstepv = dstride*_tileres.v()/nv - dstepu*(nu-1);</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">char</span>* dst = (<span class="keywordtype">char</span>*) face-&gt;getData();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ntiles;) {</div>
<div class="line">        PtexFaceData* tile = tiles[i];</div>
<div class="line"> <span class="keywordflow">if</span> (tile-&gt;isConstant())</div>
<div class="line">        PtexUtils::fill(tile-&gt;getData(), <a class="code" href="./_g_lee_8h.html#a92034251bfd455d524a9b5610cddba00">dst</a>, dstride,</div>
<div class="line">                _tileres.u()/nu, _tileres.v()/nv,</div>
<div class="line">                _pixelsize);</div>
<div class="line"> <span class="keywordflow">else</span></div>
<div class="line">        _reducefn(tile-&gt;getData(), sstride, ptileures, ptilevres,</div>
<div class="line"> <a class="code" href="./_g_lee_8h.html#a92034251bfd455d524a9b5610cddba00">dst</a>, dstride, _dt, _nchan);</div>
<div class="line">        i++;</div>
<div class="line">        dst += i%nu ? dstepu : dstepv;</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    _cache-&gt;cachelock.unlock();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// release the tiles</span></div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; ntiles; i++) tiles[i]-&gt;release();</div>
<div class="line"> <span class="keywordflow">return</span> <a class="code" href="./_g_lee_8h.html#a676ca580c460c0154eb58200433d2a9e">face</a>;</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div class="footer-block"><a class="comments-anchor" href="../html/ac.cmtdialog.htm" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
</div></body>
</html>
