<!-- saved from url=(0024)http://docs.autodesk.com -->
<html>
<head><script src="../scripts/yepnope.1.5.4-min.js" type="text/javascript"></script><script src="../scripts/lib/jquery-1.11.1.min.js" type="text/javascript"></script><meta content="text/html; charset=utf-8" http-equiv="Content-Type"/><meta content="MOBPRO" name="product"/><meta content="2018" name="release"/><meta content="GeneralUser" name="book"/><meta content="2017-09-08" name="created"/><meta content="GUID-02FA7DD3-6C7A-4C6A-B7BC-824765AE1CB2" name="topicid"/><meta content="concept" name="topic-type"/>
<title>PtexExtractor/ptex/PtexMitchellFilter.cpp</title>
</head>
<body height="100%"><div class="body_content" id="body-content"><link href="../style/navtree.css" rel="stylesheet" type="text/css"/><link href="../style/doxygen.css" rel="stylesheet" type="text/css"/><link href="../style/tabs.css" rel="stylesheet" type="text/css"/><link href="../style/adsk.cpm.css" rel="stylesheet" type="text/css"/><script language="javascript">var index = 'index.html';</script><script>$(document).ready(function() { yepnope.injectJs("./scripts/ac_common.js"); });</script><script type="text/javascript">
var tocSystemNeedsToBeLoaded = typeof(cpp_ref_adsk_ref_toc) == 'undefined';
var weAreIn21 = $('div#main.view-active').length;
var tocPrefix = '';
if (weAreIn21)
{ tocPrefix = 'cpp_ref/'; }
function cpp_ref_initializeToc(forceTrigger) {
    cpp_ref_adsk_ref_toc.initResizable();
    cpp_ref_adsk_ref_toc.initNavTree('_ptex_extractor_2ptex_2_ptex_mitchell_filter_8cpp-example.html', tocPrefix);
    dQuery(document).trigger('toc_initialized');
}
if (tocSystemNeedsToBeLoaded)
{
	yepnope([{
	load:[tocPrefix + 'json3.min.js', tocPrefix + 'jquery.js', tocPrefix + 'ref-toc-controller.js', tocPrefix + 'dynsections.js'],
	complete: function() {
	  if (typeof(dQuery) == 'undefined')
	  {
	    dQuery = jQuery.noConflict(true);
	  }
	  else { jQuery.noConflict(true); }
	  $(document).ready(cpp_ref_initializeToc);
	}
 	}])
}
if (!weAreIn21) { // if in AKN...
$(window).load( function() {
    setTimeout( function() {
        var content = $('body > div').not('#body-content');     // take any divs under body that are not id=body-content
        content.each( function() { 
            $(this).css( { 'padding-left': $(this).css('margin-left') } );       // and if they have any padding-left already, move it to margin-left.
        } );
        var width = cpp_ref_adsk_ref_toc.readFromStorage('width');
        content.css({marginLeft:parseInt(width)+6+"px"});
    }, 100);
} ); 
}
</script><script>$("div#WidgetFloaterPanels,link[href*='microsofttranslator.com'],script[src*='microsofttranslator.com'],script[src*='bing.com']").remove();</script><script type="text/javascript">$("div#navigation,div#breadcrumbs,div#banner").attr("translate","no"); var mtLocation = ((location && location.href && location.href.indexOf('https') == 0)?'https://ssl.microsofttranslator.com':'http://www.microsofttranslator.com')+'/ajax/v3/WidgetV3.ashx?ctf=True&ui=true&settings=Manual&from=en&hidelanguages='; yepnope.injectJs(mtLocation, function() {}, { charset:'utf-8', type:'text/javascript' } );</script><script>
 if (!tocSystemNeedsToBeLoaded) { cpp_ref_initializeToc(); }
 </script><!-- begin MT -->
<div class="Dark" id="MicrosoftTranslatorWidget" style="float:right;z-index:100;color:white;background-color:#bbbbbb;height:58px;overflow:hidden"></div>
<div>
<div class="head">
<h1>PtexExtractor/ptex/PtexMitchellFilter.cpp</h1>
</div>
<div id="top"><!-- Generated by Doxygen 1.8.10 -->
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="./index.html"><span>MainÂ Page</span></a></li>
<li><a href="./pages.html"><span>Topics</span></a></li>
<li><a href="./modules.html"><span>Modules</span></a></li>
<li><a href="./namespaces.html"><span>Namespaces</span></a></li>
<li><a href="./annotated.html"><span>Classes</span></a></li>
<li><a href="./files.html"><span>Files</span></a></li>
<li><a href="./examples.html"><span>Examples</span></a></li>
</ul>
</div>
</div><!-- top -->
<div class="ui-resizable side-nav-resizable" id="side-nav">
<div id="nav-tree">
<div id="nav-tree-contents">
<div class="sync" id="nav-sync"></div>
</div>
</div>
<div class="ui-resizable-handle" id="splitbar" style="-moz-user-select:none;">
</div>
</div>
<div id="doc-content">
<div class="header">
<div class="headertitle">
<div class="title">PtexExtractor/ptex/PtexMitchellFilter.cpp</div> </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">/* </span></div>
<div class="line"><span class="comment">PTEX SOFTWARE</span></div>
<div class="line"><span class="comment">Copyright 2009 Disney Enterprises, Inc.  All rights reserved</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">Redistribution and use in source and binary forms, with or without</span></div>
<div class="line"><span class="comment">modification, are permitted provided that the following conditions are</span></div>
<div class="line"><span class="comment">met:</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  * Redistributions of source code must retain the above copyright</span></div>
<div class="line"><span class="comment">    notice, this list of conditions and the following disclaimer.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  * Redistributions in binary form must reproduce the above copyright</span></div>
<div class="line"><span class="comment">    notice, this list of conditions and the following disclaimer in</span></div>
<div class="line"><span class="comment">    the documentation and/or other materials provided with the</span></div>
<div class="line"><span class="comment">    distribution.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  * The names "Disney", "Walt Disney Pictures", "Walt Disney Animation</span></div>
<div class="line"><span class="comment">    Studios" or the names of its contributors may NOT be used to</span></div>
<div class="line"><span class="comment">    endorse or promote products derived from this software without</span></div>
<div class="line"><span class="comment">    specific prior written permission from Walt Disney Pictures.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">Disclaimer: THIS SOFTWARE IS PROVIDED BY WALT DISNEY PICTURES AND</span></div>
<div class="line"><span class="comment">CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,</span></div>
<div class="line"><span class="comment">BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS</span></div>
<div class="line"><span class="comment">FOR A PARTICULAR PURPOSE, NONINFRINGEMENT AND TITLE ARE DISCLAIMED.</span></div>
<div class="line"><span class="comment">IN NO EVENT SHALL WALT DISNEY PICTURES, THE COPYRIGHT HOLDER OR</span></div>
<div class="line"><span class="comment">CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span></div>
<div class="line"><span class="comment">EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,</span></div>
<div class="line"><span class="comment">PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span></div>
<div class="line"><span class="comment">PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND BASED ON ANY</span></div>
<div class="line"><span class="comment">THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span></div>
<div class="line"><span class="comment">(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span></div>
<div class="line"><span class="comment">OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include "PtexPlatform.h"</span></div>
<div class="line"><span class="preprocessor">#include "PtexMitchellFilter.h"</span></div>
<div class="line"><span class="preprocessor">#include "PtexUtils.h"</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexMitchellFilter::setSharpness(<span class="keywordtype">float</span> sharpness)</div>
<div class="line">{</div>
<div class="line">    _sharpness = sharpness;</div>
<div class="line"> <span class="comment">// compute Mitchell filter coefficients:</span></div>
<div class="line"> <span class="comment">// abs(x) &lt; 1:</span></div>
<div class="line"> <span class="comment">//     1/6 * ((12 - 9*B - 6*C)*x^3 +</span></div>
<div class="line"> <span class="comment">//            (-18 + 12*B + 6*C)*x^2 +</span></div>
<div class="line"> <span class="comment">//        (6 - 2*B))</span></div>
<div class="line"> <span class="comment">//     == c[0]*x^3 + c[1]*x^2 + c[2]</span></div>
<div class="line"> <span class="comment">// abs(x) &lt; 2:</span></div>
<div class="line"> <span class="comment">//       ((-B - 6*C)*x3 +</span></div>
<div class="line"> <span class="comment">//        (6*B + 30*C)*x2 +</span></div>
<div class="line"> <span class="comment">//        (-12*B - 48*C)*x +</span></div>
<div class="line"> <span class="comment">//        (8*B + 24*C)) :</span></div>
<div class="line"> <span class="comment">//     == c[3]*x^3 + c[4]*x^2 + c[5]*x + c[6]</span></div>
<div class="line"> <span class="comment">// else: 0</span></div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">double</span> B = 1 - sharpness; <span class="comment">// choose C = (1-B)/2</span></div>
<div class="line">    _filter[0] = 1.5 - B;</div>
<div class="line">    _filter[1] = 1.5 * B - 2.5;</div>
<div class="line">    _filter[2] = 1 - (1./3) * B;</div>
<div class="line">    _filter[3] = (1./3) * B - 0.5;</div>
<div class="line">    _filter[4] = 2.5 - 1.5 * B;</div>
<div class="line">    _filter[5] = 2 * B - 4;</div>
<div class="line">    _filter[6] = 2 - (2./3) * B;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexMitchellFilter::eval(<span class="keywordtype">float</span>* result, <span class="keywordtype">int</span> firstchan, <span class="keywordtype">int</span> nchannels,</div>
<div class="line"> <span class="keywordtype">int</span> faceid, <span class="keywordtype">float</span> u, <span class="keywordtype">float</span> <a class="code" href="./_g_lee_8h.html#a14cfbe2fc2234f5504618905b69d1e06">v</a>,</div>
<div class="line"> <span class="keywordtype">float</span> uw1, <span class="keywordtype">float</span> vw1, <span class="keywordtype">float</span> uw2, <span class="keywordtype">float</span> vw2,</div>
<div class="line"> <span class="keywordtype">float</span> <a class="code" href="./_g_lee_8h.html#ac112eef468530a44b7a653ddac190a22">width</a>, <span class="keywordtype">float</span> blur)</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#if 0</span></div>
<div class="line"> <span class="comment">// for debugging only!</span></div>
<div class="line">    {</div>
<div class="line"> <span class="comment">// point sample highest res</span></div>
<div class="line"> <span class="keyword">const</span> FaceInfo&amp; <a class="code" href="./_g_lee_8h.html#a691492ec0bd6383f91200e49f6ae40ed">f</a> = tx-&gt;getFaceInfo(faceid);</div>
<div class="line"> <span class="keywordtype">int</span> resu = f.res.u(), resv = f.res.v();</div>
<div class="line"> <span class="keywordtype">int</span> ui = <a name="a0"></a><a class="code" href="./_g_lee_8h.html#a3878d3005eeb2d2ef414abc752ba3c9b">PtexUtils::clamp</a>(<span class="keywordtype">int</span>(u * resu), 0, resu-1);</div>
<div class="line"> <span class="keywordtype">int</span> vi = <a class="code" href="./_g_lee_8h.html#a3878d3005eeb2d2ef414abc752ba3c9b">PtexUtils::clamp</a>(<span class="keywordtype">int</span>(v * resv), 0, resv-1);</div>
<div class="line">    tx-&gt;getPixel(faceid, ui, vi, result, firstchan, nchannels);</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">/*</span></div>
<div class="line"><span class="comment">      Filter Scenarios:</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      Regular - Local res available for all faces within kernel (and no e.p.)</span></div>
<div class="line"><span class="comment">      eval at local res only (local res = desired res clamped against local max)</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">      Blended - Desired res not available for all faces, or near e.p.</span></div>
<div class="line"><span class="comment">      blend between different resolution surfaces:</span></div>
<div class="line"><span class="comment">      a) local res: filter res clamped to res of local face</span></div>
<div class="line"><span class="comment">      b) uface res: local res clamped to res of u neighbor face</span></div>
<div class="line"><span class="comment">      c) vface res: local res clamped to res of v neighbor face</span></div>
<div class="line"><span class="comment">      d) cface res: local res clamped to res of u, v and corner faces</span></div>
<div class="line"><span class="comment">      Notes:</span></div>
<div class="line"><span class="comment">      - for all evals, adjacent faces are included if they have sufficent</span></div>
<div class="line"><span class="comment">      resolution; otherwise missing pixel values are taken from local face</span></div>
<div class="line"><span class="comment">      - reuse evals that have the same res</span></div>
<div class="line"><span class="comment"> </span></div>
<div class="line"><span class="comment">      u,v blend factors are 0..1 (smoothstepped) over blend region</span></div>
<div class="line"><span class="comment">      u blend region = 2 pixels given [vface ures at edge .. local ures mid-face]</span></div>
<div class="line"><span class="comment">      v blend region = 2 pixels given [uface vres at edge .. local vres mid-face]</span></div>
<div class="line"><span class="comment">      - smoothstep between edge/mid-face resolutions (mid-face = u or v == 0.5)</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// find filter width as bounding box of vectors w1 and w2</span></div>
<div class="line"> <span class="keywordtype">float</span> uw = fabs(uw1) + fabs(uw2), vw = fabs(vw1) + fabs(vw2);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!_ctx.prepare(result, firstchan, nchannels, _tx, faceid, u, v, uw, vw))</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">double</span> weight = OneValueInv(_ctx.dt);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// get face</span></div>
<div class="line"> <span class="keyword">const</span> FaceInfo&amp; f = _tx-&gt;getFaceInfo(faceid);</div>
<div class="line">    _isConstant = f.isConstant();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// clamp filter width to no larger than 0.25 (todo - handle larger filter widths)</span></div>
<div class="line">    _ctx.uw = _ctx.uw * width + blur;</div>
<div class="line">    _ctx.vw = _ctx.vw * width + blur;</div>
<div class="line">    _ctx.uw = PtexUtils::min(_ctx.uw, 0.25f);</div>
<div class="line">    _ctx.vw = PtexUtils::min(_ctx.vw, 0.25f);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// clamp filter width to no smaller than a pixel</span></div>
<div class="line">    _ctx.uw = <a name="a1"></a><a class="code" href="./_g_lee_8h.html#a8fa4ae5e2b2ef3e57a2bde9530581904">PtexUtils::max</a>(_ctx.uw, 1.0f/(f.res.u()));</div>
<div class="line">    _ctx.vw = <a class="code" href="./_g_lee_8h.html#a8fa4ae5e2b2ef3e57a2bde9530581904">PtexUtils::max</a>(_ctx.vw, 1.0f/(f.res.v()));</div>
<div class="line"></div>
<div class="line"> <span class="comment">// compute desired texture res based on filter width</span></div>
<div class="line"> <span class="keywordtype">int</span> ureslog2 = <a name="a2"></a><a class="code" href="./_g_lee_8h.html#aa813ad7a4a00cda401ffd0c336154620">int</a>(ceil(log2(1.0/_ctx.uw))),</div>
<div class="line">    vreslog2 = <a class="code" href="./_g_lee_8h.html#aa813ad7a4a00cda401ffd0c336154620">int</a>(ceil(log2(1.0/_ctx.vw)));</div>
<div class="line">    _face.set(faceid, Res(ureslog2, vreslog2));</div>
<div class="line"></div>
<div class="line"> <span class="comment">// find neighboring faces and determine if neighborhood is constant</span></div>
<div class="line"><span class="preprocessor">#if 1</span></div>
<div class="line">    getNeighborhood(f);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// if neighborhood is constant, just return constant value of face</span></div>
<div class="line"> <span class="keywordflow">if</span> (_isConstant) {</div>
<div class="line">    PtexFaceData* <a class="code" href="./_g_lee_8h.html#a2cc7c8468af76cf855e1755c27945693">data</a> = _tx-&gt;getData(faceid, 0);</div>
<div class="line"> <span class="keywordflow">if</span> (data) {</div>
<div class="line"> <span class="keywordtype">char</span>* d = (<span class="keywordtype">char</span>*) data-&gt;getData() + _ctx.firstchan*DataSize(_ctx.dt);</div>
<div class="line">        Ptex::ConvertToFloat(_ctx.result, d, _ctx.dt, _ctx.nchannels);</div>
<div class="line">        data-&gt;release();</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// if we don't have any neighbors, just eval face by itself</span></div>
<div class="line"> <span class="keywordflow">if</span> (!_uface &amp;&amp; !_vface) {</div>
<div class="line">    evalFaces(_face.res, weight, _ctx.uw, _ctx.vw);</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// compute weights for the 4 possible surfaces</span></div>
<div class="line"> <span class="keywordtype">double</span> mweight = weight * (1 - _ublend) * (1 - _vblend); <span class="comment">// main face</span></div>
<div class="line"> <span class="keywordtype">double</span> uweight = weight * _ublend * (1 - _vblend);       <span class="comment">// u blend</span></div>
<div class="line"> <span class="keywordtype">double</span> vweight = weight * (1 - _ublend) * _vblend;       <span class="comment">// v blend</span></div>
<div class="line"> <span class="keywordtype">double</span> cweight = weight * _ublend * _vblend;         <span class="comment">// corner blend</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// eval surfaces using given weights</span></div>
<div class="line"> <span class="comment">// but first combine weights where surfaces are missing or no blending is required</span></div>
<div class="line"> <span class="keywordflow">if</span> (cweight) {</div>
<div class="line"> <span class="keywordflow">if</span> (_cface) {</div>
<div class="line"> <span class="comment">// combine w/ main if no blend needed</span></div>
<div class="line"> <span class="keywordflow">if</span> (!_cface.blend) mweight += cweight;</div>
<div class="line"> <span class="comment">// combine with an edge if res matches</span></div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_cface.res == _uface.res) uweight += cweight;</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_cface.res == _vface.res) vweight += cweight;</div>
<div class="line"> <span class="keywordflow">else</span> evalFaces(_cface.res, cweight);</div>
<div class="line">    }</div>
<div class="line"> <span class="comment">// else if (_cfaces.size() &gt; 1) {</span></div>
<div class="line"> <span class="comment">//     // todo - near an e.p., blend using linear rbf</span></div>
<div class="line"> <span class="comment">// }</span></div>
<div class="line"> <span class="keywordflow">else</span> mweight += cweight;</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (uweight) {</div>
<div class="line"> <span class="keywordflow">if</span> (!_uface.blend) mweight += uweight;</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_vface &amp;&amp; (_uface.res == _vface.res)) vweight += uweight;</div>
<div class="line"> <span class="keywordflow">else</span> evalFaces(_uface.res, uweight);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (vweight) {</div>
<div class="line"> <span class="keywordflow">if</span> (!_vface.blend) mweight += vweight;</div>
<div class="line"> <span class="keywordflow">else</span> evalFaces(_vface.res, vweight);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (mweight) {</div>
<div class="line">    evalFaces(_face.res, mweight, _ctx.uw, _ctx.vw);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexMitchellFilter::getNeighborhood(<span class="keyword">const</span> FaceInfo&amp; f)</div>
<div class="line">{</div>
<div class="line">    _uface.clear(); _vface.clear(), _cface.clear(), _cfaces.clear();</div>
<div class="line"></div>
<div class="line">    EdgeId ueid, veid;</div>
<div class="line"> <span class="keywordtype">double</span> udist, vdist;</div>
<div class="line"> <span class="keywordflow">if</span> (_ctx.u &lt; .5) { ueid = e_left;   udist = _ctx.u; } </div>
<div class="line"> <span class="keywordflow">else</span>             { ueid = e_right;  udist = 1 - _ctx.u; }</div>
<div class="line"> <span class="keywordflow">if</span> (_ctx.v &lt; .5) { veid = e_bottom; vdist = _ctx.v; }</div>
<div class="line"> <span class="keywordflow">else</span>             { veid = e_top;    vdist = 1 - _ctx.v; }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// blend zone starts at 1.5 texels in (at the current res)</span></div>
<div class="line"> <span class="comment">// to keep the kernel from accessing samples from the low-res face</span></div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> blendstart = 1.5; <span class="comment">// dist from edge (in texels) to start blending</span></div>
<div class="line"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> blendend = 2.5;   <span class="comment">// dist from edge (in texels) to stop blending</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// get u and v neighbors and compute blend weights</span></div>
<div class="line"> <span class="keywordtype">double</span> ublendstart=0, ublendend=0, vblendstart=0, vblendend=0;</div>
<div class="line"> <span class="keywordtype">int</span> ufid = f.adjfaces[ueid], vfid = f.adjfaces[veid];</div>
<div class="line"> <span class="keyword">const</span> FaceInfo* uf = 0, * vf = 0;</div>
<div class="line"> <span class="keywordflow">if</span> (ufid != -1) {</div>
<div class="line"> <span class="comment">// compute blend distances in u dir</span></div>
<div class="line"> <span class="keywordtype">double</span> texel = 1.0/_face.res.u();</div>
<div class="line">    ublendstart = PtexUtils::min(blendstart*texel, .375);</div>
<div class="line">    ublendend = PtexUtils::min(blendend*texel, 0.5);</div>
<div class="line"> <span class="comment">// get u neighbor face</span></div>
<div class="line">    uf = &amp;_ctx.tx-&gt;getFaceInfo(ufid);</div>
<div class="line">    _uface.set(ufid, uf-&gt;res, f.adjedge(ueid) - ueid + 2);</div>
<div class="line"> <span class="comment">// clamp res against desired res and check for blending</span></div>
<div class="line">    _uface.clampres(_face.res);</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">if</span> (vfid != -1)  {</div>
<div class="line"> <span class="comment">// compute blend distances in v dir</span></div>
<div class="line"> <span class="keywordtype">double</span> texel = 1.0/_face.res.v();</div>
<div class="line">    vblendstart = PtexUtils::min(blendstart*texel, .375);</div>
<div class="line">    vblendend = PtexUtils::min(blendend*texel, 0.5);</div>
<div class="line"> <span class="comment">// get v neighbor face</span></div>
<div class="line">    vf = &amp;_ctx.tx-&gt;getFaceInfo(vfid);</div>
<div class="line">    _vface.set(vfid, vf-&gt;res, f.adjedge(veid) - veid + 2);</div>
<div class="line"> <span class="comment">// clamp res against desired res and check for blending</span></div>
<div class="line">    _vface.clampres(_face.res);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// smoothstep blendwidths towards corner</span></div>
<div class="line"> <span class="keywordflow">if</span> (_uface &amp;&amp; _vface) {</div>
<div class="line"> <span class="comment">// smoothstep ublendwidth towards adj ures</span></div>
<div class="line"> <span class="keywordflow">if</span> (_vface.res.ulog2 != _face.res.ulog2) {</div>
<div class="line"> <span class="keywordtype">double</span> texel = 1.0/_vface.res.u();</div>
<div class="line"> <span class="keywordtype">double</span> adjstart = PtexUtils::min(blendstart*texel, .375);</div>
<div class="line"> <span class="keywordtype">double</span> adjend = PtexUtils::min(blendend*texel, .5);</div>
<div class="line"> <span class="keywordtype">double</span> wblend = PtexUtils::smoothstep(vdist, vblendstart, vblendend);</div>
<div class="line">        ublendstart = ublendstart * wblend + adjstart * (1-wblend);</div>
<div class="line">        ublendend = ublendend * wblend + adjend * (1-wblend);</div>
<div class="line">    }</div>
<div class="line"> <span class="comment">// smoothstep vblendwidth towards adj vres</span></div>
<div class="line"> <span class="keywordflow">if</span> (_uface.res.vlog2 != _face.res.vlog2) {</div>
<div class="line"> <span class="keywordtype">double</span> texel = 1.0/_uface.res.v();</div>
<div class="line"> <span class="keywordtype">double</span> adjstart = PtexUtils::min(blendstart*texel, .375);</div>
<div class="line"> <span class="keywordtype">double</span> adjend = PtexUtils::min(blendend*texel, .5);</div>
<div class="line"> <span class="keywordtype">double</span> wblend = PtexUtils::smoothstep(udist, ublendstart, ublendend);</div>
<div class="line">        vblendstart = vblendstart * wblend + adjstart * (1-wblend);</div>
<div class="line">        vblendend = vblendend * wblend + adjend * (1-wblend);</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// compute blend weights based on distances to edges</span></div>
<div class="line"> <span class="keywordtype">bool</span> nearu = _uface &amp;&amp; (udist &lt; ublendend);</div>
<div class="line"> <span class="keywordtype">bool</span> nearv = _vface &amp;&amp; (vdist &lt; vblendend);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!nearu) {</div>
<div class="line">    _ublend = 0;</div>
<div class="line">    _uface.clear();</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// in blend zone w/ u</span></div>
<div class="line">    _ublend = 1 - PtexUtils::qsmoothstep(udist, ublendstart, ublendend);</div>
<div class="line"> <span class="keywordflow">if</span> (_isConstant &amp;&amp; !uf-&gt;isConstant()) _isConstant = 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (!nearv) {</div>
<div class="line">    _vblend = 0;</div>
<div class="line">    _vface.clear();</div>
<div class="line">    }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// in blend zone w/ v</span></div>
<div class="line">    _vblend = 1 - PtexUtils::qsmoothstep(vdist, vblendstart, vblendend);</div>
<div class="line"> <span class="keywordflow">if</span> (_isConstant &amp;&amp; !vf-&gt;isConstant()) _isConstant = 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// gather corner faces if needed</span></div>
<div class="line">    _interior = <span class="keyword">false</span>;</div>
<div class="line"> <span class="keywordflow">if</span> (nearu &amp;&amp; nearv) {</div>
<div class="line"> <span class="comment">// gather faces around corner starting at uface</span></div>
<div class="line">    _cfaces.reserve(8); <span class="comment">// (could be any number, but typically just 1 or 2)</span></div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> cfid = ufid;           <span class="comment">// current face id (start at uface)</span></div>
<div class="line"> <span class="keyword">const</span> FaceInfo* cf = uf;       <span class="comment">// current face info</span></div>
<div class="line">    EdgeId ceid = f.adjedge(ueid);     <span class="comment">// current edge id</span></div>
<div class="line"> <span class="keywordtype">int</span> rotate = _uface.rotate;    <span class="comment">// cumulative rotation</span></div>
<div class="line"> <span class="keywordtype">int</span> dir = (ueid+1)%4==veid? 3 : 1; <span class="comment">// ccw or cw</span></div>
<div class="line"> <span class="keywordtype">int</span> <a class="code" href="./_g_lee_8h.html#a9274fa62feb8371797c4c0312446e333">count</a> = 0;             <span class="comment">// runaway loop count</span></div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">while</span> (count++ &lt; 10) {</div>
<div class="line"> <span class="comment">// advance to next face</span></div>
<div class="line"> <span class="keywordtype">int</span> eid = EdgeId((ceid + dir) % 4);</div>
<div class="line">        cfid = cf-&gt;adjfaces[eid];</div>
<div class="line"> <span class="keywordflow">if</span> (cfid == _vface.id || cfid == -1) </div>
<div class="line"> <span class="comment">// reached "vface" or boundary, stop</span></div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">        ceid = cf-&gt;adjedge(eid);</div>
<div class="line">        cf = &amp;_ctx.tx-&gt;getFaceInfo(cfid);</div>
<div class="line">        rotate += ceid - eid + 2;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// record face (note: first face (uface) is skipped)</span></div>
<div class="line">        _cfaces.push_back(Face());</div>
<div class="line">        Face&amp; <a class="code" href="./_g_lee_8h.html#a676ca580c460c0154eb58200433d2a9e">face</a> = _cfaces.back();</div>
<div class="line">        face.set(cfid, cf-&gt;res, rotate);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (_isConstant &amp;&amp; !cf-&gt;isConstant()) _isConstant = 0;</div>
<div class="line">    }</div>
<div class="line"> <span class="comment">// if we reached the vface, corner is an interior point</span></div>
<div class="line"> <span class="keywordflow">if</span> (cfid == _vface.id) {</div>
<div class="line">        _interior = <span class="keyword">true</span>;</div>
<div class="line"> <span class="comment">// see if we're regular - i.e. we have a single corner face</span></div>
<div class="line"> <span class="keywordflow">if</span> (_cfaces.size() == 1) {</div>
<div class="line">        _cface = _cfaces.front();</div>
<div class="line"></div>
<div class="line"> <span class="comment">// clamp res against u and v neighbors and check for blending</span></div>
<div class="line">        _cface.clampres(_uface.res);</div>
<div class="line">        _cface.clampres(_vface.res);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// if either u or v needs blending, corner needs blending too</span></div>
<div class="line"> <span class="keywordflow">if</span> (_uface.blend || _vface.blend)</div>
<div class="line">            _cface.blend = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="comment">// otherwise corner is an e.p. on a mesh boundary</span></div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// don't blend w/ corner faces for this case</span></div>
<div class="line">        _cfaces.clear();</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// if all faces are constant, see if all have the same value</span></div>
<div class="line"> <span class="keywordflow">if</span> (_isConstant) {</div>
<div class="line"> <span class="keywordtype">int</span> pixelsize = DataSize(_ctx.dt) * _ctx.ntxchannels;</div>
<div class="line">    PtexFaceData* data = _ctx.tx-&gt;getData(_face.id, 0);</div>
<div class="line"> <span class="keywordflow">if</span> (data) {</div>
<div class="line"> <span class="keywordtype">void</span>* constval = data-&gt;getData();</div>
<div class="line"> <span class="keywordflow">if</span> (_uface) {</div>
<div class="line">        PtexFaceData* udata = _ctx.tx-&gt;getData(_uface.id, 0);</div>
<div class="line"> <span class="keywordflow">if</span> (udata) {</div>
<div class="line"> <span class="keywordflow">if</span> (0 != memcmp(constval, udata-&gt;getData(), pixelsize))</div>
<div class="line">            _isConstant = 0;</div>
<div class="line">            udata-&gt;release();</div>
<div class="line">        }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">if</span> (_isConstant &amp;&amp; _vface) {</div>
<div class="line">        PtexFaceData* vdata = _ctx.tx-&gt;getData(_vface.id, 0);</div>
<div class="line"> <span class="keywordflow">if</span> (vdata) {</div>
<div class="line"> <span class="keywordflow">if</span> (0 != memcmp(constval, vdata-&gt;getData(), pixelsize))</div>
<div class="line">            _isConstant = 0;</div>
<div class="line">            vdata-&gt;release();</div>
<div class="line">        }</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">if</span> (_isConstant) {</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0, <a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a> = _cfaces.size(); i &lt; <a name="a3"></a><a class="code" href="./_g_lee_8h.html#a8f853268a6a93ade1ff556b79420cda3">size</a>; i++) {</div>
<div class="line">            PtexFaceData* cdata = _ctx.tx-&gt;getData(_cfaces[i].<span class="keywordtype">id</span>, 0);</div>
<div class="line"> <span class="keywordflow">if</span> (cdata) {</div>
<div class="line"> <span class="keywordflow">if</span> (0 != memcmp(constval, cdata-&gt;getData(), pixelsize)) {</div>
<div class="line">                _isConstant = 0;</div>
<div class="line"> <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">            cdata-&gt;release();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        }</div>
<div class="line">        data-&gt;release();</div>
<div class="line">    }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> PtexMitchellFilter::evalFaces(Res <a class="code" href="./_g_lee_8h.html#a1dbb21208b9047cc8031ca9c840d3c2f">res</a>, <span class="keywordtype">double</span> weight, <span class="keywordtype">float</span> uw, <span class="keywordtype">float</span> vw)</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// initialize kernel</span></div>
<div class="line"> <span class="comment">// convert u,v and filter width to (fractional) pixels</span></div>
<div class="line"> <span class="keywordtype">int</span> ures = res.u(), vres = res.v();</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (ures &lt; 4 || vres &lt; 4) {</div>
<div class="line"> <span class="comment">// can't use 4x4 mitchell, just do bilinear interp.</span></div>
<div class="line"> <span class="comment">// this should only happen for very small faces so smooth filtering shouldn't</span></div>
<div class="line"> <span class="comment">// be needed (fingers crossed)</span></div>
<div class="line"></div>
<div class="line"> <span class="comment">// todo - build 2x2 bilinear kernel</span></div>
<div class="line">    PtexFilterKernel k;</div>
<div class="line">    k.set(0, 0, 0, 1, 1, &amp;weight, 0);</div>
<div class="line">    k.apply(_face.id, 0, _ctx);</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">double</span> u = _ctx.u * ures - 0.5, v = _ctx.v * vres - 0.5;</div>
<div class="line">    uw *= ures; vw *= vres;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// find integer pixel extent: [u,v] +/- [2*uw,2*vw]</span></div>
<div class="line"> <span class="comment">// (mitchell is 4 units wide for a 1 unit filter period)</span></div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> <a class="code" href="./_g_lee_8h.html#ab296853c9d55bfdc62cda6c50d1b4781">u1</a> = <a class="code" href="./_g_lee_8h.html#aa813ad7a4a00cda401ffd0c336154620">int</a>(ceil(u - 2*uw)), <a class="code" href="./_g_lee_8h.html#a1c6bf6fa786a04b729b30e56d68474ef">u2</a> = <a class="code" href="./_g_lee_8h.html#aa813ad7a4a00cda401ffd0c336154620">int</a>(ceil(u + 2*uw));</div>
<div class="line"> <span class="keywordtype">int</span> <a class="code" href="./_g_lee_8h.html#a0779c3b73f9aa3a0ac5b0139b5d291d9">v1</a> = <a class="code" href="./_g_lee_8h.html#aa813ad7a4a00cda401ffd0c336154620">int</a>(ceil(v - 2*vw)), <a class="code" href="./_g_lee_8h.html#a9a09a1837922b2b806f4589096a52049">v2</a> = <a class="code" href="./_g_lee_8h.html#aa813ad7a4a00cda401ffd0c336154620">int</a>(ceil(v + 2*vw));</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">int</span> kuw = <a class="code" href="./_g_lee_8h.html#a1c6bf6fa786a04b729b30e56d68474ef">u2</a>-<a name="a4"></a><a class="code" href="./_g_lee_8h.html#ab296853c9d55bfdc62cda6c50d1b4781">u1</a>, kvw = <a class="code" href="./_g_lee_8h.html#a9a09a1837922b2b806f4589096a52049">v2</a>-<a name="a5"></a><a class="code" href="./_g_lee_8h.html#a0779c3b73f9aa3a0ac5b0139b5d291d9">v1</a>;</div>
<div class="line"> <span class="keywordflow">if</span> (kuw &gt; 8 || kvw &gt; 8) {</div>
<div class="line"> <span class="comment">// shouldn't happen - but just in case...</span></div>
<div class="line">    assert(kuw &lt;= 8 &amp;&amp; kvw &lt;= 8);</div>
<div class="line"> <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// compute kernel weights along u and v directions</span></div>
<div class="line"> <span class="keywordtype">double</span>* ukernel = (<span class="keywordtype">double</span>*)alloca(kuw * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div>
<div class="line"> <span class="keywordtype">double</span>* vkernel = (<span class="keywordtype">double</span>*)alloca(kvw * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div>
<div class="line">    computeWeights(ukernel, (u1-u)/uw, 1.0/uw, kuw);</div>
<div class="line">    computeWeights(vkernel, (v1-v)/vw, 1.0/vw, kvw);</div>
<div class="line"> <span class="keywordtype">double</span> <a class="code" href="./_g_lee_8h.html#a281421b881aa7a1266842b73a3bc7655">scale</a> = weight;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// skip zero entries (will save a lot of work later)</span></div>
<div class="line"> <span class="keywordflow">while</span> (!ukernel[0])     { ukernel++; u1++; kuw--; }</div>
<div class="line"> <span class="keywordflow">while</span> (!ukernel[kuw-1]) { kuw--; }</div>
<div class="line"> <span class="keywordflow">while</span> (!vkernel[0])     { vkernel++; v1++; kvw--; }</div>
<div class="line"> <span class="keywordflow">while</span> (!vkernel[kvw-1]) { kvw--; }</div>
<div class="line"></div>
<div class="line"> <span class="keywordtype">double</span> sumu = 0; <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; kuw; i++) sumu += ukernel[i];</div>
<div class="line"> <span class="keywordtype">double</span> sumv = 0; <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; kvw; i++) sumv += vkernel[i];</div>
<div class="line">    scale /= sumu * sumv;</div>
<div class="line"></div>
<div class="line"> <span class="comment">// compute tensor product to form rectangular kernel</span></div>
<div class="line"> <span class="keywordtype">double</span>* kbuffer = (<span class="keywordtype">double</span>*) alloca(kuw*kvw*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));</div>
<div class="line"> <span class="keywordtype">double</span>* kp = kbuffer;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; kvw; i++, kp += kuw) {</div>
<div class="line"> <span class="keywordtype">double</span> vk = vkernel[i] * <a name="a6"></a><a class="code" href="./_g_lee_8h.html#a281421b881aa7a1266842b73a3bc7655">scale</a>;</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; kuw; j++) kp[j] = ukernel[j]*vk;</div>
<div class="line">    }</div>
<div class="line">    PtexFilterKernel k; k.set(res, u1, v1, kuw, kvw, kbuffer, kuw);</div>
<div class="line"></div>
<div class="line"> <span class="comment">// split kernel across edges into face, u,v, and corner parts</span></div>
<div class="line">    PtexFilterKernel ku, kv, kc;</div>
<div class="line">    k.split(ku, kv, kc);</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (ku || kv) {</div>
<div class="line"> <span class="comment">// merge kernel parts back in for missing/insufficient-res faces</span></div>
<div class="line"> <span class="keywordflow">if</span> (kc) {</div>
<div class="line"> <span class="keywordflow">if</span> (!_cface &amp;&amp; _interior) {</div>
<div class="line"> <span class="comment">// valence-3 interior case</span></div>
<div class="line"> <span class="comment">// clear corner and renormalize kernel</span></div>
<div class="line"> <span class="keywordtype">double</span> amt = 1.0/(1 - kc.totalWeight()/weight);</div>
<div class="line">        kc.clear();</div>
<div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">double</span> *kp = kbuffer, *<a class="code" href="./_g_lee_8h.html#a432111147038972f06e049e18a837002">end</a> = kbuffer + kuw*kvw; kp != <a name="a7"></a><a class="code" href="./_g_lee_8h.html#a432111147038972f06e049e18a837002">end</a>; kp++)</div>
<div class="line">            *kp *= amt;</div>
<div class="line">        }</div>
<div class="line"> <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!_cface || !(_cface.res &gt;= res)) {</div>
<div class="line"> <span class="comment">// merge corner into u and/or v faces</span></div>
<div class="line"> <span class="keywordflow">if</span> (kv &amp;&amp; _uface) {</div>
<div class="line"> <span class="keywordflow">if</span> (_vface) {</div>
<div class="line"> <span class="comment">// merge corner 50% into ku and kv faces</span></div>
<div class="line">            ku.merge(kc, kv.eidval(), 0.5);</div>
<div class="line">            kv.merge(kc, ku.eidval(), 0.5);</div>
<div class="line">            }</div>
<div class="line"> <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// merge corner into ku across v edge</span></div>
<div class="line">            ku.merge(kc, kv.eidval());</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line"> <span class="comment">// merge corner into kv across u edge</span></div>
<div class="line">            kv.merge(kc, ku.eidval());</div>
<div class="line">        }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> <span class="comment">// merge boundary edges into main kernel</span></div>
<div class="line"> <span class="keywordflow">if</span> (ku &amp;&amp; (!_uface || !(_uface.res &gt;= res)))</div>
<div class="line">        k.merge(ku, ku.eidval());</div>
<div class="line"> <span class="keywordflow">if</span> (kv &amp;&amp; (!_vface || !(_vface.res &gt;= res)))</div>
<div class="line">        k.merge(kv, kv.eidval());</div>
<div class="line"></div>
<div class="line"> <span class="keywordflow">if</span> (ku) ku.apply(_uface.id, _uface.rotate, _ctx);</div>
<div class="line"> <span class="keywordflow">if</span> (kv) kv.apply(_vface.id, _vface.rotate, _ctx);</div>
<div class="line"> <span class="keywordflow">if</span> (kc) kc.apply(_cface.id, _cface.rotate, _ctx);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"> <span class="comment">// eval faces</span></div>
<div class="line">    k.apply(_face.id, 0, _ctx);</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<div class="footer-block"><a class="comments-anchor" href="../html/ac.cmtdialog.htm" target="_blank"><span class="comments-link">Please send us your comment about this page</span></a></div></div>
</div></body>
</html>
